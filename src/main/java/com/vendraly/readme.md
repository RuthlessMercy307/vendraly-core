Cosas a implementar
=
Trabajos:
Herrero: Sus armas y herramientas crafteadas tienen una probabilidad (basada en el nivel) de recibir un encantamiento aleatorio de bajo nivel (ej: Unbreaking I o Sharpness I) o m√°s durabilidad. peque√±a probabilidad de sus herramientas o armas salir con 1 punto de vida

Boticario: Sus pociones creadas tienen una probabilidad (basada en el nivel) de recibir una duraci√≥n mayor (en segundos) o un nivel de efecto superior (ej: Strength II en lugar de Strength I). peque√±a probabilidad de sus pociones explotar

Sastre: Sus armaduras tienen una probabilidad (basada en el nivel) de recibir un encantamiento aleatorio de bajo nivel,  peque√±a probabilidad de sus armaduras salir con 1 punto de vida

Le√±ador: Gana un aumento de da√±o y velocidad con hacha Generaci√≥n de Mobs Hostiles: Al talar madera, tiene una probabilidad creciente (basada en el nivel) de que aparezca un mob espec√≠fico ejemplo un oso)

Minero: Gana un aumento de velocidad de minado con pico. La mina tiene un loot especial (dinero de mina o √≠tems de mejora de herramientas) solo obtenible con el trabajo activo. PvP Obligatorio/Riesgo de P√©rdida: Los recursos valiosos est√°n en zonas PvP de la mina. Si muere, pierde sus "mejoras de herramientas" temporales (√≠tems en su inventario) a manos de su asesino.

Pescador: Puede craftear y usar ca√±as de pescar tem√°ticas (ca√±a de libros, ca√±a de comida) que aumentan la probabilidad de un loot espec√≠fico. Aparici√≥n de Mob hostil: Una probabilidad de que al pescar, en lugar de un pez, un mob hostil fuerte (ej: Guardi√°n Elder con nombre personalizado) aparezca cerca y lo ataque.

Repartidor: Dinero garantizado por entrega exitosa. Si no se le paga al d√≠a (porque no hizo entregas), pierde un peque√±o porcentaje de su dinero total (mantenimiento de Elytra). P√©rdida por Tiempo/Costo: Si no llega a tiempo, el jugador pierde el dinero que gast√≥ en cohetes para el viaje

Cocinero: Dinero garantizado y capacidad de crear alimentos de alta calidad (con efectos de poci√≥n casi que como las manzanas xD) para el resto de los jugadores.  crear alimentos de alta calidad (con efectos de poci√≥n permanentes o m√°s intensos) para el resto de los jugadores.P√©rdida de Ingredientes: Si el tiempo l√≠mite expira o usa los ingredientes incorrectos

Gar√ßom (Mesero): Es uno de los trabajos m√°s f√°ciles de ganar dinero r√°pido. P√©rdida por Movimiento: Si se mueve demasiado r√°pido (saltos, sprinting constante) mientras sostiene el "plato" (un √≠tem personalizado), el plugin puede detectar el movimiento y destruir el √≠tem, forz√°ndolo a empezar de nuevo.

Ladr√≥n: Capacidad de robar √≠tems aleatorios de otros jugadores (usando la API de Inventario). Beneficio Extra: Al usar la habilidad, temporalmente obtiene la skin de algun mob del juego y se le oculta el nombre por cierto tiempo, Riesgo/Sistema de Detenci√≥n: Si es detectado por un Guardia (el Guardia lo derriba al casi matarlo), pierde todo el dinero e items que tenia encima y es enviado a la c√°rcel.

Guardia: Gana una bonificaci√≥n de dinero significativa por cada Ladr√≥n que detiene/encarcela. abran npc ladrones tambien y un tiempo limite para perseguir el ladron. Costo de Servicio: Si el Guardi√°n no detecta y detiene a un Ladr√≥n por un periodo de tiempo, pierde una peque√±a cantidad de dinero por "negligencia" (mantener el sistema de ley es costoso).

Cazador: Recompensa en Dinero y Loot por cr√°neos/cabezas de mobs o jugadores fugitivos (PvP). Aumento de Hostilidad de Mobs: En las zonas de caza, los mobs le causan m√°s da√±o que a un jugador normal, por ser un depredador conocido.

Clanes:
Los jugadores podran crear un clan al comprar el nexus del clan (un standarte especial) con limite de 5 mienbros,

Para expandir la cantidad de mienbros en el clan deben raidear a otros y  destruir el nexus para conseguirlo, y de esta forma al fucionar los dos nexus se consiguen uno de mayor nivel

Al un clan destruir otro la prote del clan destruido desaparece

Las protecciones de los jugadores que pertenecen al clan cuentan como cosas del clan, no como cosas de los jugadores individuales (pa que si se meten al clan ps son una familia, si quieren sus cosas individuales ps que juegueen solos)

El clan podra comprar cositas que son como granjas (que seran caras la verdad) parecidas a las de bedwars, que sueltan algun item como hierro, oro, diamantes, etc pasivamente, y las pueden mejorar para que suelte mas cosas pero siempre sera caro, ademas debe comprarse con el dinero del clan (que se deposita en el nexus, asi si los raidean tambien les pueden quitar el botin del clan xd)

Un clan no puede ser atacar ni ser atacado por otro clan si solo tiene 1 mienbro del clan conectado, necesita minimo 2 conectados para poder habilitar la opcion (Lo cual me parece poco pero no creo que superemos las 5 personas dentro del  serverxd)

si un jugador abandona un clan, debe esperar 3 dias (de la vida real) para poder entrar a otro
si el jugador abandona el clan no se lleva las protecciones ni recupera el dinero que puso en el nexus

Crafteo de armas y armaduras:
Los jugadores deberan subir sus habilidades pasivas (se mejoran al ser usadas) de crafting
al tener niveles bajos tendran poca vida/resistencia todas las cosas que craftee ademas de titulos bajos, y niveles mas altos dan titulos mejores
Titulos:
-comun
-raro
-epico
-legendario
-mitico


las armas no suman da√±o, sino que te dejan usar el da√±o que tienes, igual con la velocidad, ejemplo, golpe con mano da√±o maximo 5, espada de madera da√±o maximo 10, espada de piedra da√±o maximo 15, espada de hierro da√±o maximo 30, espada de diamante da√±o maximo 50, espada de netherite da√±o maximo sin limite

la velocidad de ataque tambien va cambiando, pero tiene un minimo tambien, ejemplo, no puedes usar netherite si no tienes tu nivel de ataque por lo menos 51, la de diamante minimo 31 y asi, para cosas como picos o hachas tienen su da√±o y velocidad tambien, ya que la velocidad la mejoramos como habilidades

las herramientas que tenga un material mejor te permite usar mas de tu velocidad/da√±o etc, mientras que tu nivel de habilidad de crafteo las comunes raras y esas asi, la calidad cambia solo la durabilidad, puede haber una espada de madera legendaria, o una de netherite comun y asi, tambie para cada una dependiendo el material para crear una de buena calidad no solo necesitas el material y el mismo nivel que una de madera, necesitas nivel de crafteo mas alto

las armas y armaduras tienen atributos dependiendo de su calidad
-comun 1 atributos
-raro 2 atributos
-epico 3 atributos
-legendario 4 atributos
-mitico 5 atributos

ademas de niveles que los niveles dan mas estadisticas a esos atributos
los niveles de los atributos van de acuerdo con el nivel de la habilidad, ejemplo:
un sastrero de nivel 50 puede hacer que un arma salga nivel 50 o menos

Saqueo de cofres con descubrimiento:
Al igual que otros juegos como por ejemplo KCD1 o Arena Breackout
al "robar/abrir" debes descrubrir item por item dandole click, para poder ver que es y luego tomarlo, haciendo que no solo sea abrir y agarrar todo, pero los cofres que ya conoces no tendran ese estilo de carga
se le aplica el mismo tipo de descubrir cuando inspeccionas/robas del inventario de otro jugador directamente

la habilidad agilidad va a hacer que el descubrimiento sea mas rapido o lento

Hechizos y funciones con voz (ya fue agregado como plugin aparte)
el mod de voz al detectar que dice la gente, y dependiendo la palabra si cumplen X requisitos puedan usar Hechizos

se introduciran algunas armas unicas que aun no se deciden cuales seran, cuando se dice unica es que no hay otra igual a esa, ya que tendra una habilidad perzonalisada

Tendran que matar algunos boss para poder conseguir jefes que aun no se decide cuales seran
-enderman: item que teletransporta si te pegan (probabilidades)
-Thor?
-Gigante de fuego
-Rey esqueleto
-dragon (ya viene pero ahora m√°s op)
-serpiente del mar que olvide su nombre 
y no se que otros jefes poner pero por ahora solo esos

Para descubrir algunas cosas deben seguir el lore, ya que le dara informacion para descubrir los puzles y desbloquear nuevas zonas  o conseguir algun item especial


-No forma de conseguir reparacion ya que sera eliminada con un plugin, las unicas cosas con reparacion seran las armas o armaduras unicas

Sistema de robo y inspecci√≥n publico
similar a lo de los cofres pero es con un comando
al hacer el comando ejemplo /robar ruthless se intentara robar al usuario ruthless si esta por lo menos a 5 bloques de distancia (que ya me parece mucho, tal vez sea mejor 3) pero como funciona? ps tienes que descubrir item por item como con los cofres que viene ofuscado pero ahora aplicado al inventario del jugador que intentas robar
mientras que con inspeccion es diferente, aunque tambien te permita ver el inventario del jugador enemigo con ofuscamiento y debas descubrir uno a uno, en modo inspeccion no podras tomar nada del inventario, ademas que el tiene la opcion de ocultar algunos 
para el usuario que esta siendo inspeccionado porder ocultar algun item, esto es un ocultamiento temporal, debe darle click a ese item, de esta forma el item comenzara un conteo regresivo (coldown como cuando atacas con un arma o tocas una trompeta y aunque esta en inventario se le ve el coldown) al ese coldown acabar el objeto se muestra pero el jugador inspeccionado puede volverle a dar click antes del coldown acabar para poder rellenarlo de nuevo y asi ocultarlo mas tiempo, ejemplo de rellenado, si el primer daba 3 segundos de ocultamiento, cuando quedaba 1 segundo para ser mostrado al darle click vuelve a estar con los 3 segundos de coldown

Ataque y defensa kcd1:
Estaba pensando mucho como hacerlo, ser√° m√°s que como kdcd1 mas un tipo mount and blade

-Las direcciones se ven arriba del player con una flecha fantasma que te muestra la direccion, hay 5 direcciones (como en kingdom come deliverace 1 pero sin el del medio)
-si un jugador se defiende con la espada (solo tiene espada a mano y mas nada) obtiene inmunidad de esa direcci√≥n por x tiempo (tal vez 1 segundo ya que los ataques normalmente lo hacen a 1.8 para el m√°ximo da√±o)
-el ataque dependera tambien la direccion, y tendra un peque√±o coldown antes de hacerce efectivo de 0.3segundos (ese tiempo para test) asi el jugador enemigo tiene tiempo de reaccionar
-Defensa solo disponible con espadas
-defensa perfecta vs inperfecta: al hacer una defensa perfecta (durante del coldown antes del ataque hacerce efectivo, se mostrara un icono peque√±o en pantalla para saber si esta en el momento perfecto o no) no importa a que direccion defendio, al ser una perfecta el ataque del enemigo no vale nada, hace 0 da√±o, y el enemigo pierde bastante estamina, mientras que con una defensa imperfecta, osea que se defendio en la direccion correcta pero no durante el momento perfecto, esto hara que el jugador que defendio pierda estamina pero no recibe el da√±o
-combos: tambien se podran hacer combos especificos, para que de esta forma al alguien hacerlo con exito (ejempo: arriba, derecha, derecha abajo) el tercer golpe en el caso de ese combo de ejemplo no le afectaria la defensa, no importa si es defensa perfecta o inperfecta, hara el 100% del da√±o y hara al enemigo perder estamina, pero el combo es valido solo si todos los golpes fueron defendido con defensa inperfecta, y en cierto tiempo para evitar que hoy me defiendes y ma√±ana te termino el combo


seguridad en cofres:
ya que los cofres no estan bloqueados por protecciones (salvo no tengan por lo menos 1 del clan o el due√±o del cofre online) existiran los cofres con llave tambien
Cierto tipo de cofres tienen candado (deben comprarlo) tendr√° una llave para poder abrirlo
Si compran ganzua entran en minijuego para abrir el cofre
Bloque de detector de intruso: detecta si alguien paso por encima de el, te da el nombre la hora y el d√≠a
Puerta con llave: puerta que se abre solo con la llave en la mano o ganzua
Puerta con detector: puerta que detecta quien intenta abrirla, si es el due√±o o alguien con permiso lo deja, sino se queda ah√≠ nom√°s cerrada
Tal vez piensen que eso ya pasa con plugins de protecci√≥n, pero en mi caso el plugin lo hago yo, y aunque est√©s en protecci√≥n si t√∫ cofre o tu puerta no es de estas cualquiera puede entrar, sla protecci√≥n es solo para que no rompan nada ni hagan spawn mobs dentro de tu zona (y no se si poner algo extra)
As√≠ con eso de las puertas y las llaves ni los de tu clan tendr√° permiso por un lado
-las ganzuas tienen limite de uso antes de romperse, pero solo se rompen si fallan el minijuego al intentar abrir cofres o algo

Party:
los jugadores podran tener party dependiendo su honor, mientras mas honor mas personas en su party, las personas de la party no pueden estar demasiado lejos, deben estar almenos a 500 bloques de distancia (o tal vez menos pq 500 parece mucho), mientras tanto, todos los que esten dentro de la party recibiran recomensas iguales, pero 50% menos a la original independiente de la cantidad de personas, de esta forma, si hay 3 persnas en la party es mas conveniente, ya que asi digamos que a 1 jugador le deberia dar 10 de dinero y 10 de exp por matar un slime lvl 5, ahora como anda en party de 2 le daria 5 de dinero y exp a cada jugador, si hay 3 jugadores en la party entonces le da 5 de dinero y exp a cada jugador, si hay 4 en la party le da 5 de dinero y exp a cada igualmente

--Mobs sueltan dinero (olvide ponerlo)

derribado:
los jugadores no mueren instantaneamente, sino que quedan derribados en el suelo al tener 1 corazon de vida y obtienen inmortalidad hasta que se acabe el tiempo y se terminen de morir, para alguien revivirlo debe estar almenos a 2 bloques de distancia de el y estar agachado (shift) para revivirlo

Secuestros:
si un jugador esta derribado, tienen la opcion de revivirlo o secuestrarlo, al usar /secuestrar [nombre] y estar a almenos 3 bloques de distancia, el jugador se vuelve peque√±o y quedara en tu espalda, ademas de que se le restaurara 3 puntos de vida, leugo con el /soltar [nombre] soltaras al jugador, pero estara con hambre y 2 corazones de vida

grilletes: 
para encarcelar jugadores o al secuestrarlos, deberas usar grilletes, que hacen que el jugador al que se los pusistes (le diste click derecho al jugador mientras tenias el item en la mano) el jugador quedara congelado, y se volvera inmortal mientras tenga grilletes, osea, siempre tendra 2 corazones de vida y 1 punto de comida, para liberarlo debes usar las llaves que conseguiste con el grillete para que asi se pueda ir

Portal al cielo:
para ir a un templo en el cielo se puede ir con un portal, creando un 4x5 de piedra luminosa y un bloque de agua en el centro, de esta forma se creara el portal al cielo (que nada mas te da tp a un lugar que estara marcado como cielo con el comando /cielo)

dragon:
podras volar en dragones, usaremos a algun mob como el happy ghast pero con las texturas del dragon del end, para que jugadores puedan volarlo (pero eso es cierta recompensa)

comando para -Murcielago mensajero
lo que hace es que al poner el /murcielagomensajero [jugador destino] mensaje. el murcielago le llevara a ese jugador un libro que contiene el mensaje para que lo lea,para el jugador saber cual era el murcieralo, el murcielago lo atacara pero no le hara da√±o, y el libro lo dropea


-Las proteccion es para que no destruyan los otros jugadores, ni quemen, pero los mobs si pueden rompertela

-Los cofres protegen si est√°s offline, si est√°s online se desprotegen (pa que roben en tu caraxd)

-Proteccion solo protege de jugadores y mobs

las protecciones no se hacen con un bloque, se compran con un comando, con tama√±o perzonalisado, el que prefieran, solo que deben pagar un precio por cada espacio protegido, ejemplo si es un 5x5x5 deben pagar por los 125 bloques que esten protegiendo asi sea de aire

las protecciones les deben poner nombre para identificarlas, asi saber si quieren eliminar alguna o algo

las protecciones pagan impuestos por las tierras, si el jugador compra una proteccion demasiado grande 1000x100x1000 los impuestos seguiran cobrandose y si el jugador no tiene dinero para pagar esos impuestos, entonces la proteccion desaparecera

si un jugador entra a un clan sus protecciones dejan de ser de el y pasan a ser del clan, los impuestos los paga el clan, si el jugador abandona el clan no se lleva las protecciones ni recupera el dinero que puso en el nexus

que los monstruos tambi√©n tengan lvl, cada x tiempo el nivel de los nuevos monstruos va subiendo, y se pueda configurar tambi√©n oleadas a las bases de jugadores (d√≥nde est√°n las piedras con protecci√≥n) (esto ya lo hicimos pero tiene algunos bugs)

los portales est√°n bloqueados, osea la gente no puede andar por ah√≠ cruzandolos, adem√°s de construirlos deben comprar un pase, el pase tiene 1 uso y se consume al cruzas el portal, de esa forma deben conseguir "dinero" y gastarlo en cosas √∫tiles as√≠, y no viajar√°n cada tres segundos sino que viajar√°n intentando conseguir la mayor cantidad de cosas sin andar ida y vuelta a cada rato (a menos que farmeen dinero)

compran y venden objetos a npc, y hacen trade entre jugadores por dinero, cumplen misiones diarias para conseguir dinero

al matar monstruos consigues exp de siempre, y dependiendo tu nivel puede ponerte mas fuerza, m√°s vida, m√°s velocidad de picar, de talar, o cosas asi, que sea ilimitado ya que ser√° dif√≠cil ganar exp


los jugadores ganan dinero tambi√©n participando en directos de los streamers del server, o conversando o haciendo llamadas en el server de discord, as√≠ aunque no est√©n en el juego pueden ganar dinero y apoyamos al sv de dc y a los streamers en twitch

esquivar: al darle shift los jugadores esquivan ataques, lo que los hace invulnerabels por x tiempo con coldown de x tiempo (ya fue implementado)

cosas para agregar que aun no detallo
=
Mazmorras generadas proceduralmente
Reliquias antiguas (√≠tems √∫nicos en el servidor que tienen historia y cambian de due√±o).
Cofres mimics: cofres que se transforman en mobs cuando intentas abrirlos.
Mec√°nica de reliquias malditas: ciertos √≠tems atraen mobs si los llevas en el inventario.
Sistema de reputaci√≥n/fama:
NPC bardos: los jugadores pueden pagarles para contar historias o rumores.
Carreras de caballos con apuestas.
Arena de gladiadores con ranking mundial (ELO PvP).
Minijuego de dados/cartas en tabernas para ganar √≠tems raros.
Sistema de m√∫sica: instrumentos que reproducen melod√≠as y sirven como buffos (bardos).
Territorios reclamables: jugadores o gremios pueden conquistar regiones y cobrar impuestos.
Sistema de bandidos NPC que atacan caravanas de aldeanos y secuestran jugadores para pedir dinero para el rescate
Econom√≠a din√°mica: precios suben o bajan seg√∫n escasez de recursos en el servidor.
IA tipo ‚Äúdungeon master‚Äù (plugin que genera misiones seg√∫n la actividad de los jugadores). ?Xd
Econom√≠a realista: inflaci√≥n, impuestos, bancos con pr√©stamos.
Caza de recompensas PvP: los criminales con m√°s robos aparecen en tabl√≥n de se busca.
Reclamar aldeas / impuestos

Puedes hacer que cada aldea sea un ‚Äúterritorio fiscal‚Äù.

El jugador/gremio que la controla recibe una renta peri√≥dica (dinero por cada aldeano).

Los aldeanos siguen trabajando normal, pero cada cierto tiempo pagan impuestos que va al due√±o.

Se puede permitir ‚Äúrevuelta‚Äù de aldeanos si el impuesto es muy alto o si el due√±o tiene mala reputaci√≥n ‚Üí los aldeanos pueden dejar de trabajar, huir, o hasta pedir ayuda a otros jugadores.

Los due√±os pueden ‚Äúmejorar‚Äù la aldea: guardias, murallas, talleres. Eso multiplica la renta.

Lo de los ‚Äúesclavos‚Äù estilo huevos de aldeano queda como un √≠tem raro de mercado negro ‚Üí un aldeano encapsulado que puedes liberar donde quieras. Puede dar rol tanto para los de mala fama (tr√°fico de aldeanos) como para los de buena fama (fundar aldeas nuevas).
Los seguidores npc si lo puedo hacer? Xd pq osea, tendr√≠a que hacer que persigan al due√±o y puedan pelear como si fueran jugadores de verdad, que ataquen a cualquiera que les haga da√±o, a cualquiera que haga da√±o a los de su "party" y a cualquiera que el due√±o le pegue (algo as√≠ como los perros ahora que pienso pero en versi√≥n jugadores npcxd)

‚ö™ Buena fama:
Contratos exclusivos: NPCs nobles solo dan misiones a h√©roes reconocidos.
Seguidores NPC: puedes contratar escuderos, aprendices o mercenarios baratos.
Poder pol√≠tico: si tu fama es muy alta, puedes ser autom√°ticamente propuesto como l√≠der de una aldea o ciudad.
Acceso a √°reas sagradas: templos, bibliotecas secretas, reliquias m√°gicas que NPCs no mostrar√°n a ‚Äúbandidos‚Äù.
Los bandidos intentan secuestrarte cada x tiempo

‚ö´ Mala fama
Mercado negro: acceso a objetos ilegales (armas malditas, pociones prohibidas).
Aliados criminales: NPCs bandidos no te atacan, incluso te dan misiones.
Infamia como poder: tu nombre aparece en tablones de ‚ÄúSe busca‚Äù, otros jugadores o NPCs te cazan ‚Üí pero si sobrevives ganas bonus

Documentaci√≥n de Componentes Clave
=
(VendralyCore)
El Flujo de Datos Cr√≠tico: PlayerData, UUID y AuthManager
   Este es el concepto m√°s importante para prevenir bugs de sincronizaci√≥n y garantizar la seguridad de los datos:

Reglas Inmutables del Estado del Jugador:
Origen (Conexi√≥n): El evento de conexi√≥n (PlayerJoinEvent) proporciona el UUID y el Name del jugador.

Carga (Persistencia): El AuthManager utiliza el UserDataManager para leer el archivo [UUID].yml y crear un √∫nico objeto PlayerData en la memoria (cach√©).

Fuente de Verdad (Cach√©): Mientras el jugador est√° conectado, el objeto PlayerData almacenado en el AuthManager es la √öNICA fuente de verdad para sus datos (balances, roles, estad√≠sticas).

Uso Correcto: NUNCA se debe leer o escribir directamente al UserDataManager o a la API de Bukkit para obtener datos de un jugador online. Siempre se debe obtener el objeto PlayerData del AuthManager.

Markdown

// Ejemplo de Uso CORRECTO para jugadores ONLINE:
PlayerData data = plugin.getAuthManager().getPlayerData(player.getUniqueId());

// Modificar datos directamente en el objeto en memoria
data.setBalance(data.getBalance() + 50.0);

UserDataManager.java
=
   El UserDataManager es la capa de entrada/salida (I/O) del plugin. Su √∫nico trabajo es mover datos entre el disco (archivos YAML) y la memoria (PlayerData). No gestiona el estado en memoria, solo la persistencia.

Funciones Principales de Persistencia
getPlayerConfig(UUID uuid):

Prop√≥sito: Obtiene o crea el objeto YamlConfiguration (el archivo YAML) para un jugador.

Nota: Utiliza un cach√© ligero para evitar re-leer el disco repetidamente.

savePlayerConfig(UUID uuid):

Prop√≥sito: Guarda el objeto YamlConfiguration que est√° en cach√© en el disco (.yml).

Nota: Debe llamarse solo si se modific√≥ el YamlConfiguration directamente.

loadPlayerData(UUID uuid, String username):

Prop√≥sito: M√©todo Can√≥nico de Carga. Lee todos los datos (Auth, Economy, RPG) del archivo YAML y crea una nueva instancia de PlayerData.

Nota: Usado por el AuthManager solo al conectar un jugador.

savePlayerData(PlayerData data):

Prop√≥sito: M√©todo Can√≥nico de Guardado. Toma el objeto PlayerData de la memoria (del AuthManager), lo serializa y lo guarda al archivo YAML.

Nota: Es la funci√≥n principal de guardado. Se llama al desconectar y despu√©s de cambios cr√≠ticos.

unloadPlayer(UUID uuid):

Prop√≥sito: Limpia la cach√© de configuraci√≥n (YamlConfiguration) del jugador en el UserDataManager.

Nota: Se llama al desconectarse (despu√©s de que se hayan guardado los datos).

saveAll():

Prop√≥sito: Fuerza el guardado de todas las configuraciones YAML pendientes en el cach√©.

Nota: CR√çTICO. Se llama justo antes de que el plugin se apague (onDisable).

Funciones de Utilidad (Offline/Chequeo)
setPlayerRole(UUID uuid, Role role):

Prop√≥sito: Utilidad Offline. Cambia directamente el rol de un jugador en el archivo YAML y actualiza su historial.

Nota: Usado principalmente para comandos administrativos en jugadores offline.

getUUIDFromUsername(String username):

Prop√≥sito: B√∫squeda As√≠ncrona. Intenta obtener el UUID de un jugador a partir de su nombre (buscando online y luego en los archivos YAML).

Nota: LENTO. Necesario para comandos de moderaci√≥n como /vban <nombre> si el jugador est√° offline.

isRegistered(UUID uuid):

Prop√≥sito: Comprueba el estado de registro directamente en el archivo YAML.

Nota: Se utiliza para verificar el estado de registro de jugadores offline.

playerFileExists(UUID uuid):

Prop√≥sito: Verifica si el archivo de datos ([UUID].yml) existe en el disco.

getPlayerName(UUID uuid):

Prop√≥sito: Obtiene el √∫ltimo nombre conocido de un jugador desde el archivo YAML.

CashManager.java
=
El CashManager se encarga de gestionar todas las operaciones de la econom√≠a de efectivo robable (cash_balance). Su principal objetivo es asegurar que todas las operaciones de I/O sean as√≠ncronas y que la arquitectura de cach√© (AuthManager) se respete rigurosamente.

Regla Fundamental: Flujo Bifurcado
El CashManager utiliza dos caminos l√≥gicos para garantizar la seguridad de los datos:

Jugador ONLINE: Accede al PlayerData directamente desde el cach√© del AuthManager (lectura y modificaci√≥n instant√°nea). No toca el disco.

Jugador OFFLINE: Carga el PlayerData del disco a trav√©s del UserDataManager (lento, as√≠ncrono), aplica el cambio, y guarda al disco.

Funciones As√≠ncronas Principales
getBalance(UUID uuid):

Prop√≥sito: Obtiene el saldo de efectivo de forma as√≠ncrona.

Nota: Si est√° ONLINE, lee del cach√© (r√°pido). Si est√° OFFLINE, lee del disco (lento).

modifyBalance(UUID uuid, double amount):

Prop√≥sito: A√±ade o resta una cantidad al saldo de efectivo de forma as√≠ncrona.

Nota: Mantiene la integridad: Si est√° OFFLINE, guarda los cambios al disco inmediatamente. Si est√° ONLINE, modifica el objeto en memoria para que el AuthManager lo guarde al desconectar.

transferCash(UUID sender, UUID recipient, double amount):

Prop√≥sito: Transfiere una cantidad entre dos jugadores de forma as√≠ncrona.

Nota: Utiliza una cadena de promesas (thenCompose) para garantizar que la resta y la suma ocurran secuencialmente (Transacci√≥n "casi-at√≥mica").

getCash(UUID uuid):

Prop√≥sito: Alias de conveniencia para getBalance(uuid).

modifyCash(UUID uuid, double amount):

Prop√≥sito: Alias de conveniencia para modifyBalance(uuid, amount).

üõë Advertencia: M√©todos Sincr√≥nicos (.join())
Los siguientes m√©todos son provistos para conveniencia en la API de Bukkit, pero bloquean el hilo principal (el juego) hasta que la operaci√≥n as√≠ncrona termina. Su uso debe minimizarse solo a comandos y eventos que puedan tolerar un peque√±o retraso.

getBalance(Player player): Obtiene el saldo s√≠ncronamente.

take(Player player, double amount): Resta efectivo s√≠ncronamente (ej. al comprar).

give(Player player, double amount): Da efectivo s√≠ncronamente.

EconomyManager.java
=
El EconomyManager gestiona el saldo bancario (balance) de los jugadores. Al igual que el CashManager, utiliza un flujo de datos bifurcado para respetar la arquitectura central (AuthManager) y asegurar que todas las operaciones de disco sean as√≠ncronas.

Arquitectura de Acceso Seguro
Jugador ONLINE: Los accesos de lectura y modificaci√≥n se dirigen al objeto PlayerData en el cach√© del AuthManager (acceso instant√°neo).

Jugador OFFLINE: La carga y el guardado se dirigen al disco a trav√©s del UserDataManager (proceso as√≠ncrono).

Funciones As√≠ncronas Principales
getBalance(UUID uuid):

Prop√≥sito: Obtiene el saldo bancario de forma as√≠ncrona.

Nota: Si est√° ONLINE, lee del cach√©. Si est√° OFFLINE, lee del disco de forma segura.

modifyBalance(UUID uuid, double amount):

Prop√≥sito: A√±ade o resta una cantidad al saldo bancario de forma as√≠ncrona, con validaci√≥n de saldo negativo.

Nota: Si el jugador est√° OFFLINE, guarda los datos al disco. Si est√° ONLINE, modifica el objeto en memoria y el AuthManager se encarga del guardado posterior.

transferBalance(UUID sender, UUID recipient, double amount):

Prop√≥sito: Transfiere una cantidad entre dos jugadores de forma as√≠ncrona.

Nota: Implementa una l√≥gica secuencial (thenCompose) para verificar el saldo del remitente antes de ejecutar la transferencia, garantizando la integridad de la transacci√≥n.

DamageLimitListener.java
=
El DamageLimitListener implementa el sistema de L√≠mite de Da√±o por Arma, crucial para el balance del sistema RPG. Asegura que los jugadores con niveles altos de Fuerza no puedan usar armas de baja calidad para infligir da√±o excesivo.

Arquitectura y Dependencias
Este Listener depende del StatManager para obtener las estad√≠sticas RPGStats del jugador y asume que el StatManager ya ha aplicado el bono de da√±o al evento antes de que este Listener se ejecute.

Utiliza la librer√≠a Adventure para la notificaci√≥n de la barra de acci√≥n (sendActionBar).

Funciones Principales
extractDamageLimit(ItemStack item):

Prop√≥sito: Analiza el Lore del arma (ItemStack) para encontrar una l√≠nea espec√≠fica (p. ej., "L√≠mite de Da√±o: 50").

Resultado: Devuelve el valor del l√≠mite, expresado en Puntos RPG de Fuerza. Si no encuentra un l√≠mite o si la l√≠nea es "SIN L√çMITE", devuelve un valor alto por defecto.

onPlayerAttack(EntityDamageByEntityEvent event):

Prop√≥sito: Intercepta el evento de da√±o cuerpo a cuerpo de un jugador.

L√≥gica de L√≠mite (CR√çTICA):

Compara los Puntos de Fuerza del jugador con el l√≠mite de Puntos de Fuerza permitido por el arma.

Si los Puntos del jugador son mayores que el l√≠mite, el da√±o debe ser limitado.

Calcula el Da√±o Base de Bukkit (Da√±o de arma + vanilla) restando el bono RPG total aplicado por el StatManager.

Calcula el Bono RPG M√°ximo Permitido usando el l√≠mite del arma.

Establece el da√±o final del evento como la suma del Da√±o Base de Bukkit y el Bono RPG M√°ximo Permitido.

Notificaci√≥n: Env√≠a un mensaje de acci√≥n al jugador indicando que su da√±o fue limitado.

ItemRequirementListener.java
=
El ItemRequirementListener implementa el sistema de Restricci√≥n de √çtems basado en las estad√≠sticas RPG del jugador. Su prop√≥sito es impedir que los jugadores usen armas o herramientas de alto nivel si no han invertido suficientes puntos en el atributo requerido.

Arquitectura y Dependencias
Este Listener depende completamente del StatManager para obtener el objeto RPGStats del jugador y leer sus niveles de atributos (e.g., Fuerza, Velocidad).

Funciones Principales
extractRequirement(ItemStack item, String requirementType):

Prop√≥sito: Analiza el Lore de un √≠tem en busca de una l√≠nea espec√≠fica que contenga el requisito m√≠nimo (p. ej., "Requisito M√≠nimo de Fuerza: 50").

Resultado: Devuelve el valor num√©rico del requisito (50 en el ejemplo), o 0 si no se encuentra.

onEntityDamage(EntityDamageByEntityEvent event):

Prop√≥sito: Bloquea los ataques si el jugador no cumple con los requisitos del arma.

Bloqueo de Fuerza: Verifica si el nivel de Fuerza del jugador cumple con el requisito "Fuerza" del arma. Si falla, cancela el evento (event.setCancelled(true)) y notifica al jugador.

Verificaci√≥n de Velocidad: Verifica un requisito "Velocidad" (si existe), pero solo notifica al jugador que el arma se siente pesada; no cancela el da√±o.

onBlockBreak(BlockBreakEvent event):

Prop√≥sito: Bloquea la recolecci√≥n de bloques si el jugador no cumple con los requisitos de la herramienta.

Bloqueo de Recolecci√≥n: Verifica si el nivel de Fuerza del jugador (o el stat de recolecci√≥n si se implementa) cumple con el requisito "Fuerza" de la herramienta. Si falla, cancela el evento y notifica al jugador.

LootRestrictionListener.java
=
El LootRestrictionListener es un componente de balance de juego cuyo objetivo principal es bloquear la obtenci√≥n del encantamiento Reparaci√≥n (Mending) de fuentes que podr√≠an desequilibrar la progresi√≥n del servidor.

Funciones Principales
isMendingBook(ItemStack item):

Prop√≥sito: Funci√≥n de utilidad crucial para verificar si un ItemStack es un Libro Encantado que contiene el encantamiento Enchantment.MENDING.

Mecanismo: Utiliza EnchantmentStorageMeta para inspeccionar los encantamientos almacenados dentro del libro.

onPlayerFish(PlayerFishEvent event):

Prop√≥sito: Bloquea la obtenci√≥n de Mending a trav√©s de la Pesca (una fuente com√∫n de Loot o "Tesoro").

Mecanismo: Si el objeto capturado es un libro de Mending, cancela el evento, elimina el objeto del mundo y notifica al jugador.

onLootChestOpen(InventoryOpenEvent event):

Prop√≥sito: Bloquea la obtenci√≥n de Mending de cofres generados que contienen bot√≠n, como cofres de mazmorras o barriles.

Mecanismo: Se dispara cuando un jugador abre un inventario. Itera sobre el contenido del cofre/barril y, si encuentra un libro de Mending, lo elimina del inventario y notifica al jugador.

NOTA DE ARQUITECTURA: Este m√©todo usa InventoryOpenEvent, que es limitado y puede actuar en cofres colocados por jugadores. Es una restricci√≥n de gameplay amplia para la progresi√≥n de Mending.

PlayerListener.java
=
El PlayerListener es el componente de m√°s alto nivel que gestiona el ciclo de vida del jugador, la seguridad de autenticaci√≥n y la inicializaci√≥n del estado RPG (vida, atributos, scoreboard).

Arquitectura de Seguridad (Login Wall)
Utiliza un Set<UUID> (unauthenticatedPlayers) para bloquear todas las interacciones de un jugador hasta que el LoginCommand o RegisterCommand llame a onLoginSuccess().

Depende del AuthManager para determinar si un jugador est√° registrado y para marcar su estado de logout.

Funciones Principales
onPlayerJoin(PlayerJoinEvent event):

Prop√≥sito: Punto de entrada para la seguridad y la inicializaci√≥n.

Mecanismo: Verifica el estado de autenticaci√≥n con el AuthManager. Si no est√° autenticado, a√±ade el UUID al set de bloqueo y env√≠a el mensaje de /login o /register. Si ya estaba logueado, llama a onLoginSuccess.

onPlayerQuit(PlayerQuitEvent event):

Prop√≥sito: Limpieza y guardado final.

Mecanismo: Elimina el scoreboard, retira el UUID de la lista local de bloqueo, y llama a authManager.logoutPlayer() para guardar los datos de forma as√≠ncrona y marcar el estado de logout.

Bloqueos (onPlayerMove, onCommandPreprocess, onBlockBreak, onBlockPlace):

Prop√≥sito: Implementar la barrera de autenticaci√≥n.

Mecanismo: Cancelan todas las interacciones si el jugador est√° en el set de unauthenticatedPlayers, excepto por los comandos /login y /register.

onLoginSuccess(Player player):

Prop√≥sito: Inicializaci√≥n cr√≠tica del jugador tras una autenticaci√≥n exitosa (llamado desde LoginCommand).

Mecanismo:

Desbloquea al jugador (unauthenticatedPlayers.remove()).

Carga el rol y permisos (authManager.loadRoleFromData).

Aplica los atributos RPG (Fuerza, Vida M√°xima) del StatManager.

Sincroniza la barra de XP vanilla.

OCULTA LA BARRA DE VIDA VANILLA y aplica el scoreboard con un retraso de 1 tick (runTaskLater) para evitar fallos de sincronizaci√≥n con el cliente.

isUnauthenticated(Player player):

Prop√≥sito: M√©todo de utilidad para que otros Listeners (como el de Chat) comprueben el estado de bloqueo del jugador.

StatListener.java
=
El StatListener es el controlador principal del sistema de estad√≠sticas RPG y la capa de balance de gameplay. Centraliza la l√≥gica de consumo de estamina, la reducci√≥n de da√±o basada en estad√≠sticas, y el control de la experiencia.

Arquitectura de Balance
Depende fuertemente del StatManager para el acceso a las estad√≠sticas (RPGStats) en memoria y para la gesti√≥n de la BossBar de Estamina y los cooldowns.

Utiliza una constante FLAT_DAMAGE_REDUCTION_PER_DEFENSE_POINT para aplicar una reducci√≥n de da√±o fijo (no porcentual) a todo el da√±o recibido.

L√≥gica de Estamina y Consumo de Acci√≥n
tryConsumeStamina(...):

Prop√≥sito: Funci√≥n de utilidad para verificar el cooldown de cansancio, intentar consumir el costo y notificar al jugador.

CR√çTICO: Si la estamina no se puede consumir (o est√° en cooldown), retorna false, lo que se usa para cancelar la acci√≥n f√≠sica (ataque, salto, minado).

onPlayerToggleSprint(PlayerToggleSprintEvent):

Mecanismo: Bloquea al jugador si intenta empezar a correr y est√° en cooldown o no tiene el m√≠nimo de estamina (STAMINA_MINIMUM_FOR_SPRINT).

onPlayerMove(PlayerMoveEvent):

Prop√≥sito: Controla el consumo de estamina por Salto.

Mecanismo: Detecta el movimiento vertical ascendente desde un bloque s√≥lido y utiliza tryConsumeStamina. Si falla, cancela el evento de movimiento y ajusta la velocidad vertical para evitar el salto.

onEntityDamageByEntity(EntityDamageByEntityEvent):

Prop√≥sito: Gasto de estamina por Ataque.

Mecanismo: Llama a tryConsumeStamina. Si el consumo falla (por falta de estamina o cooldown), cancela el evento de da√±o para bloquear el ataque.

onBlockBreak(BlockBreakEvent):

Prop√≥sito: Gasto de estamina por Trabajo (minado, talado).

Mecanismo: Llama a tryConsumeStamina. Si falla el consumo, cancela el evento de rotura de bloque.

L√≥gica de Combate y Defensa
onEntityDamage(EntityDamageEvent):

Prop√≥sito: Aplica la reducci√≥n de da√±o RPG a todo el da√±o entrante.

Mecanismo: Calcula la reducci√≥n fija (FLAT_DAMAGE_REDUCTION_PER_DEFENSE_POINT * statDefense) y la resta del da√±o final, asegurando que el resultado no sea negativo.

L√≥gica de Experiencia y Nivel
onPlayerExpChange(PlayerExpChangeEvent):

Prop√≥sito: Intercepta y anula la ganancia de EXP Vanilla de Minecraft.

Mecanismo: Traduce la cantidad de EXP vanilla a EXP RPG, la a√±ade a RPGStats (que maneja la l√≥gica de subida de nivel), y luego establece event.setAmount(0) para bloquear el sistema de nivel de Minecraft.

handleLevelUp(...):

Prop√≥sito: L√≥gica ejecutada por RPGStats cuando se sube de nivel.

Mecanismo: Otorga puntos de habilidad (addUnspentPoints), aplica los nuevos atributos al jugador y fuerza la actualizaci√≥n de scoreboards y schedulers.

Gesti√≥n de Men√∫
onInventoryClick(InventoryClickEvent):

Prop√≥sito: Maneja la interacci√≥n del jugador con el Men√∫ de Atributos RPG.

Mecanismo: Comprueba que el t√≠tulo coincida, cancela el evento (para evitar robo de √≠tems), y si el jugador tiene puntos disponibles, llama a applyPointToStat(...) en la estad√≠stica correspondiente. Tras el gasto, guarda los datos y re-abre el men√∫.

onPlayerQuit(PlayerQuitEvent):

Prop√≥sito: Limpieza de la sesi√≥n.

Mecanismo: Elimina la BossBar de estamina, elimina los efectos de poci√≥n RPG (lentitud, prisa) y guarda el PlayerData final (incluyendo vida y estamina actuales) antes de la desconexi√≥n.

TradeListener.java
=
El TradeListener es un Listener de alta complejidad, esencial para el sistema de Tradeo Seguro. Controla cada interacci√≥n del inventario y bot√≥n dentro de la interfaz de tradeo para garantizar que los √≠tems y el dinero se intercambien de forma segura y solo cuando ambos jugadores est√©n listos.

Arquitectura de Seguridad
Dependencia: Totalmente dependiente de TradeManager y TradeSession para gestionar el estado, las ofertas y los botones.

Identificaci√≥n: Utiliza un identificador de t√≠tulo de inventario estricto (TRADE_TITLE_IDENTIFIER) para asegurar que solo los inventarios de tradeo sean afectados.

Funciones Principales
onInventoryClick(InventoryClickEvent event):

Prop√≥sito: Manejar toda la l√≥gica de movimiento de √≠tems, botones de efectivo y el estado de "Listo".

Bloqueo: Cancela cualquier clic en slots del otro jugador, separadores, y slots de control/oferta (cancelar, estado, botones de dinero).

Manejo de Ofertas:

Si el clic es en un bot√≥n de dinero (P1_INCREASE_10, etc.), calcula la nueva oferta.

Llama a session.setMoneyOffer(player, newOffer), que se encarga de verificar el saldo y resetear autom√°ticamente el estado de "Listo" para ambos jugadores si la oferta de dinero cambia.

Manejo de Estado/√çtems:

Si el clic es en el slot de Estado/Aceptar, llama a session.toggleReady(player).

Si el clic es en el slot de √≠tems propios o si se produce un movimiento de √≠tem (shift-click desde el inventario inferior), resetea el estado de "Listo" (session.resetReadyStatus).

onInventoryDrag(InventoryDragEvent event):

Prop√≥sito: Prevenir que el jugador arrastre √≠tems a slots que no le corresponden.

Mecanismo: Itera sobre todos los slots afectados por el arrastre. Si alg√∫n slot pertenece al otro jugador o es un slot de control, cancela el evento.

Reset de Estado: Si el arrastre es en los slots de √≠tems propios, resetea el estado de "Listo".

onInventoryClose(InventoryCloseEvent event):

Prop√≥sito: Finalizar y limpiar la sesi√≥n si un jugador cierra manualmente la interfaz.

Mecanismo: Llama a session.returnItems() para devolver los √≠tems a ambos jugadores. Luego, llama a tradeManager.endTrade(session) para cerrar la sesi√≥n de forma segura y cerrar el inventario del otro jugador.

VillagerTradeListener.java
=
El VillagerTradeListener reemplaza el sistema de tradeo por esmeraldas de Minecraft por una moneda de efectivo digital (CashManager), rebalanceando la econom√≠a de los aldeanos. Adem√°s, es un punto de control clave para prohibir el encantamiento Mending.

Arquitectura y Seguridad
Moneda Personalizada: Utiliza Material.EMERALD con CUSTOM_MODEL_DATA para crear un √≠tem que representa la moneda digital (CashStack).

Balance As√≠ncrono: Emplea tareas as√≠ncronas (thenAccept y runTask) para interactuar con CashManager, asegurando que el juego no se congele durante la consulta o modificaci√≥n del saldo del jugador.

Bloqueo de Concurrencia: Usa un Map de locks por UUID de aldeano (getLockForVillager) para sincronizar el acceso a la lista de recetas, previniendo race conditions durante la apertura y el tradeo.

Funciones Principales
onInventoryOpen(InventoryOpenEvent):

Conversi√≥n: Itera sobre todas las recetas del aldeano y llama a convertRecipeToCash(...).

Eliminaci√≥n de Mending: Descarta cualquier receta cuyo resultado sea un Libro Encantado de Reparaci√≥n (Mending).

Balance: Convierte todas las esmeraldas de ingredientes en un CashStack de valor ajustado (PRICE_MULTIPLIER), eliminando la necesidad de esmeraldas f√≠sicas.

Forzado de Nivel: Fuerza el nivel del aldeano a Maestro (5) y la experiencia a Integer.MAX_VALUE.

onTradeSelect(TradeSelectEvent):

Control Total: Cancela inmediatamente el evento (event.setCancelled(true)) para tomar el control manual del proceso de tradeo.

Verificaci√≥n de Mending: Bloquea y notifica al jugador si la receta seleccionada produce Mending.

Flujo de Cobro Manual (Cr√≠tico):

Verifica si el jugador tiene los ingredientes de √≠tem (no Cash).

Consulta el saldo del jugador (cashManager.getCash).

Si tiene fondos, modifica el saldo del jugador (cashManager.modifyBalance, de forma as√≠ncrona).

Si el cobro tiene √©xito, llama a consumeIngredients() para eliminar los √≠tems de ingrediente del inventario.

Llama a applyTrade() para darle el √≠tem resultado.

Llama a incrementTradeUsesAndExperience() para simular el uso de la receta, la experiencia del aldeano y el reset del trade (rebalance).

consumeIngredients(Player, MerchantRecipe):

CR√çTICO: Nueva funci√≥n que itera sobre los ingredientes de la receta (ignorando el CashStack) y elimina las cantidades necesarias del inventario del jugador, previniendo el glitch de √≠tems gratis.

getAdjustedMaxUses(...):

Limita el n√∫mero de usos de la receta a un m√°ximo de 12 (MAX_USES_CAP) para un rebalance continuo.

Role.java
=
El enumerador Role es el componente fundamental para la gesti√≥n de permisos y jerarqu√≠a dentro del servidor. Define todos los grupos de usuarios, desde la administraci√≥n hasta los rangos VIP y el jugador por defecto.

Arquitectura de Roles
Rol	Jerarqu√≠a	isOp()	Permisos Clave
OWNER	Administrativo	true	Acceso total (se le otorga OP)
DEVELOPMENT	Administrativo	true	Acceso total (se le otorga OP)
MODERADOR	Staff de Moderaci√≥n	false	ban, unban, gamemode, teleport
HELPER	Staff de Soporte	false	teleport (Ayuda)
MEDIA	Estatus/Especial	false	Ninguno (solo prefijo)
VIP	Estatus/VIP	false	Ninguno (solo prefijo)
PLAYER	Por Defecto	false	Ninguno

AbilityManager.java
=
El AbilityManager administra la progresi√≥n de las habilidades secundarias del jugador (ej. Sastrer√≠a, Herrer√≠a) y las habilidades de inversi√≥n de puntos (ej. Agilidad). Es la capa de l√≥gica que se encuentra entre la entrada de EXP y la actualizaci√≥n de los RPGStats.

L√≥gica Clave y Mecanismos
EXP Acumulada (F√≥rmula RPG):

La experiencia requerida para cada nivel se calcula mediante una f√≥rmula de crecimiento r√°pido: 50 * (Nivel ^ 1.8).

El m√©todo checkSkillLevelUp es crucial. Ahora maneja la EXP Sobrante (currentExp - requiredExpForCurrentLevel) para evitar la p√©rdida de progreso si el jugador sube m√∫ltiples niveles a la vez.

Habilidades de Inversi√≥n de Puntos (AGILITY):

Se introduce el concepto de habilidades que usan Puntos de Habilidad en lugar de EXP pasiva (determinado por AbilityType.usesPoints()).

getAbilityPoints / setAbilityPoints se utilizan para manipular directamente el nivel de habilidades como AGILITY, que se usar√° para el sistema de Ofuscamiento de Cofres.

Seguridad y L√≠mites:

Todas las ganancias de EXP y subidas de nivel est√°n limitadas por el valor maxLevel definido en el enumerador AbilityType.

Se realiza un guardado de datos (plugin.getUserDataManager().savePlayerData) en cada actualizaci√≥n de EXP o puntos, garantizando la persistencia del progreso.

M√©todos Principales
M√©todo	Prop√≥sito	Seguridad
addExp(...)	A√±ade EXP y gatilla la subida de nivel para habilidades pasivas.	Verifica usesPoints() y getMaxLevel().
checkSkillLevelUp(...)	Contiene el bucle de subida de nivel y la l√≥gica de retenci√≥n de EXP sobrante.	Asegura que el nivel no exceda maxLevel.
getAbilityPoints(...)	Obtiene el nivel de una habilidad activa (ej. AGILITY).	Devuelve el nivel (puntos invertidos).
setAbilityPoints(...)	Establece el nivel de una habilidad activa despu√©s de que el jugador invierte puntos.	Llama a savePlayerData inmediatamente.
getRequiredExpForNextLevel(...)	Calcula la EXP TOTAL acumulada necesaria para alcanzar el siguiente nivel.	Usa la f√≥rmula de crecimiento exponencial.

AbilityType.java
=
Este enumerador sirve como el cat√°logo maestro para todas las habilidades secundarias del sistema RPG. Su objetivo principal es definir la estructura de datos que utiliza el AbilityManager para gestionar la progresi√≥n de los jugadores.

Estructura y Prop√≥sito
Cada constante en el enum (TAILORING, AGILITY, etc.) encapsula los siguientes metadatos:

Nombre Visible (displayName): C√≥mo se muestra la habilidad al jugador.

Descripci√≥n (description): Una breve explicaci√≥n de su beneficio en el juego.

Nivel M√°ximo (maxLevel): El tope de progresi√≥n, asegurando que el grindeo no sea infinito.

Tipo de Progresi√≥n (usesPoints): Una bandera cr√≠tica que diferencia las habilidades:

false (Pasiva): Sube de nivel ganando experiencia (ej. MINING).

true (Activa): Sube de nivel al invertir Puntos de Habilidad (ej. AGILITY).

Impacto de AGILITY: La inclusi√≥n de AGILITY con usesPoints = true diferencia claramente este tipo de habilidad, lo cual es esencial para el sistema de ofuscamiento de cofres que planeas implementar.

ApothecaryListener.java
=
Este Listener gestiona la progresi√≥n y los beneficios de la habilidad de Alquimia (APOTHECARY), la cual est√° enfocada en mejorar las pociones.

Mecanismo de Progresi√≥n
La principal limitaci√≥n de la API de Bukkit es que el BrewEvent no proporciona el jugador que inicia la preparaci√≥n de la poci√≥n. Por ello, este sistema utiliza un enfoque de doble capa:

onPotionBrew (Marcador Temporal): Al producirse la poci√≥n, solo se aplica una bonificaci√≥n temporal/marcador con nivel 0 a la PotionMeta. Esto sirve para preparar la poci√≥n para el siguiente paso.

grantExpAndNotify (Ejecuci√≥n Final): Esta es la funci√≥n cr√≠tica que debe ser llamada externamente por un Custom Brew Handler (un listener que detecta cu√°ndo el jugador saca el √≠tem de la mesa de pociones). Solo esta funci√≥n puede obtener el nivel real del jugador, aplicar la EXP y modificar los efectos de la poci√≥n de manera permanente y correcta.

Bonificaci√≥n de Pociones
La habilidad aplica un modificador llamado Poder de Poci√≥n (POTION_POWER_LORE_PREFIX).

F√≥rmula: La bonificaci√≥n es de 0.5% extra de duraci√≥n o efecto por nivel de habilidad. Un jugador con Nivel 100 de Alquimia aplicar√° un +50% de Poder de Poci√≥n.

Aplicaci√≥n de Efectos: La bonificaci√≥n real se aplica modificando los efectos (PotionEffect) incrustados en la poci√≥n, aumentando su duraci√≥n (duration). La l√≥gica es robusta y busca preservar el lore existente mientras inyecta la nueva estad√≠stica.

Compatibilidad: Se usa el m√©todo meta.addCustomEffect(effect, true) con el argumento overwrite para garantizar la compatibilidad con diferentes versiones de la API.

BlacksmithingListener.java
=
Este Listener es el n√∫cleo del sistema de crafteo de armas y herramientas, implementando la habilidad de Herrer√≠a (BLACKSMITHING). Su principal funci√≥n es inyectar la l√≥gica de RPG en los √≠tems reci√©n crafteados, garantizando que el nivel de la habilidad afecte directamente la calidad y utilidad del equipo.

Mecanismos Principales
1. Requisitos de Materiales
   Se mantiene una estructura est√°tica (MATERIAL_REQUIREMENTS) que mapea cada tipo de arma/herramienta (Madera, Piedra, Diamante, etc.) con sus requisitos espec√≠ficos:

Nivel M√≠nimo de Herrer√≠a: Dificultad base de la receta, crucial para el c√°lculo de calidad.

L√≠mite de Stat (Da√±o/Utilidad): Establece el tope de da√±o o utilidad que el √≠tem puede ofrecer, limitado por el Stat de Fuerza del jugador.

Requisitos M√≠nimos (Fuerza/Velocidad): Stats m√≠nimos que el jugador debe poseer para usar el √≠tem sin penalizaci√≥n.

2. C√°lculo de Calidad y Durabilidad
   Al craftear un √≠tem, el Listener:

Calidad: Utiliza QualityUtility para determinar la calidad (Raro, √âpico, etc.) comparando el nivel de Herrer√≠a del jugador con el requisito m√≠nimo del material.

Durabilidad Inicial: La calidad obtenida se traduce directamente en la durabilidad inicial del √≠tem. Una calidad superior significa menos da√±o inicial aplicado (Damageable.setDamage), comenzando el √≠tem con una durabilidad cercana al 100%.

3. Lore Din√°mico y Requisitos de Stats
   El lore del √≠tem es generado din√°micamente (applyBlacksmithingBonus) y es fundamental para la interacci√≥n RPG:

Nombre y Calidad: El nombre del √≠tem es prefijado por su calidad y color correspondiente.

Requisitos de Personaje: Muestra los requisitos de Fuerza y Velocidad. El color del texto es verde si el jugador los cumple, y rojo si no, proporcionando feedback inmediato al jugador.

L√≠mite de Stat: Muestra el tope de da√±o/utilidad. Si el Stat de Fuerza del jugador excede el l√≠mite del √≠tem, el texto se vuelve rojo, indicando que el √≠tem est√° limitando el potencial del jugador.

4. Generaci√≥n de Atributos y Experiencia
   Atributos Aleatorios: Se determina la cantidad de atributos extra que el √≠tem debe recibir, bas√°ndose en la calidad. El proceso de aplicaci√≥n de los atributos se delega a la clase AttributeGenerator.

Ganancia de EXP: La experiencia es otorgada utilizando AbilityManager, aplicando un multiplicador si el jugador usa Shift-Click para craftear m√∫ltiples √≠tems a la vez, garantizando un flujo de progresi√≥n justo.

TailoringListener.java
=
Este Listener gestiona la habilidad de Sastrer√≠a (TAILORING), la cual aplica toda la l√≥gica de RPG a las armaduras (cuero, malla, hierro, etc.) crafteadas por el jugador.

Integraci√≥n Centralizada
A diferencia de otras habilidades que aplican el lore y los atributos directamente, Sastrer√≠a delegan la generaci√≥n de √≠tems a la clase RPGItemGenerator. Esto asegura que las armaduras, que son complejas por sus m√∫ltiples slots y estad√≠sticas, sean consistentes con el resto del sistema RPG.

Mecanismos Principales
1. Requisitos de Materiales
   Se define una lista est√°tica (MATERIAL_REQUIREMENTS) para todas las piezas de armadura. Esta lista establece dos valores clave para cada material:

L√≠mite M√°ximo de Defensa (maxDefenseLimit): El tope de la estad√≠stica Defensa que el √≠tem puede tener. Este valor se inyecta en el lore del √≠tem.

Nivel M√≠nimo de Sastrer√≠a (minTailoringLevel): La dificultad base para craftear el √≠tem, esencial para que el generador calcule la Calidad final.

2. Generaci√≥n y Atributos
   La funci√≥n onCraftArmadura realiza el siguiente flujo:

Generaci√≥n Delegada: Llama a itemGenerator.generateRPGItem(), pasando el nivel de Sastrer√≠a del jugador y la dificultad del material. Esta llamada es responsable de:

Determinar la Calidad (Com√∫n, Raro, √âpico, etc.).

Aplicar un nombre basado en la Calidad y el color correspondiente.

Generar e inyectar atributos aleatorios.

Aplicar el lore de requisitos de stats.

Durabilidad Basada en Calidad: Una vez que el RPGItemGenerator ha determinado la calidad, el Listener calcula la durabilidad inicial del √≠tem. Un √≠tem de mayor calidad comienza con mucha menos penalizaci√≥n de da√±o (cercano al 0), reflejando una manufactura superior.

3. Progresi√≥n
   Experiencia: Se otorga experiencia (EXP) variable basada en la dificultad del material (siendo Netherita la que m√°s EXP concede). La experiencia se ajusta autom√°ticamente si el jugador usa Shift-Click para craftear m√∫ltiples piezas.

Notificaci√≥n: El jugador es notificado de la calidad del √≠tem crafteado y la EXP obtenida, utilizando la utilidad QualityUtility para mostrar el color correcto.

AttributeApplier.java
=
Esta clase es la responsable de la sincronizaci√≥n entre las estad√≠sticas RPG personalizadas del jugador (almacenadas en RPGStats) y los atributos de Minecraft (Max Health, Attack Damage, Movement Speed). Act√∫a como un puente entre la l√≥gica del juego y la API nativa de Bukkit/Spigot.

Mecanismos de Aplicaci√≥n
El m√©todo central es applyPlayerAttributes(Player, RPGStats), que se invoca cuando las estad√≠sticas de un jugador cambian (por ejemplo, subida de nivel, equipamiento, o al iniciar sesi√≥n).

1. Vida (Max Health)
   C√°lculo: La vida m√°xima del jugador es recalculada utilizando la f√≥rmula RPGStats.BASE_HEALTH + statHealth * RPGStats.HEALTH_PER_POINT.

Sincronizaci√≥n: El valor nativo de Attribute.MAX_HEALTH se establece con este nuevo valor. Tambi√©n ajusta la vida actual del jugador si esta excede el nuevo m√°ximo (previniendo exploits).

2. Da√±o (Attack Damage)
   Base: Establece el valor base de da√±o de Minecraft (2.0).

Modificador: Aplica un AttributeModifier (usando una NamespacedKey √∫nica) que escala directamente con el Stat de Fuerza del jugador, sum√°ndolo al da√±o base.

3. Velocidad (Movement Speed)
   Base: Establece la velocidad base de Minecraft (BASE_MC_SPEED).

Modificador: Aplica un AttributeModifier que aumenta la velocidad en una cantidad peque√±a por cada punto en el Stat de Velocidad del jugador.

4. Defensa y Reducci√≥n de Da√±o
   La clase incluye constantes clave para el balance del juego, aunque la aplicaci√≥n de la Defensa M√°gica y la Reducci√≥n de Da√±o Plano se gestiona en las clases de Listener de da√±o (DamageListener).

FLAT_DAMAGE_REDUCTION_PER_DEFENSE_POINT: Constante utilizada por el sistema de combate.

getAbilityBonusMagicDefense: Calcula la Defensa M√°gica adicional que el jugador obtiene por su nivel en la habilidad de Sastrer√≠a.

Robustez y Limpieza
El m√©todo removeAttributeModifiers es cr√≠tico para la estabilidad. Antes de aplicar nuevos stats, garantiza que todos los modificadores antiguos (AttributeModifier) aplicados por este plugin sean eliminados. La limpieza se realiza de la manera m√°s robusta, utilizando las NamespacedKey definidas en el constructor y, como fallback, revisando nombres legados (legacyNames) para asegurar la compatibilidad durante las actualizaciones.

LevelingManager.java
=
Esta clase es el motor del sistema de progresi√≥n RPG. Se encarga de gestionar la adici√≥n de experiencia, el c√°lculo de los requisitos de EXP para los siguientes niveles y la aplicaci√≥n de los beneficios al subir de nivel, tanto para el Nivel Principal del jugador como para las Habilidades Secundarias.

Mecanismos de Progresi√≥n
1. Escalado de Experiencia
   El m√©todo getRequiredExpForNextLevel utiliza un sistema de crecimiento exponencial para garantizar que la progresi√≥n sea cada vez m√°s lenta y desafiante:

EXP
requerida
‚Äã
=BASE_REQUIRED_EXP√ó(REQUIRED_EXP_SCALING_FACTOR)
(Nivel‚àí1)

Con un factor de 1.20, la EXP requerida aumenta un 20% por cada nivel.

2. Adici√≥n y Verificaci√≥n de EXP (addExp)
   Nivel Principal (MAIN): La EXP se a√±ade a stats.getTotalExperience(). Al subir de nivel, el jugador recibe 3 Puntos de Atributo sin gastar (POINTS_PER_LEVEL) para distribuir en sus stats principales (Fuerza, Vitalidad, etc.).

Habilidades Secundarias: La EXP se a√±ade al registro espec√≠fico de la habilidad (ej. BLACKSMITHING, TAILORING). La subida de nivel de una habilidad se notifica con un mensaje que resume su nuevo beneficio.

3. Sincronizaci√≥n con Minecraft
   Barra de Experiencia: La funci√≥n updatePlayerExpBar toma la EXP del nivel principal del jugador y la traduce con precisi√≥n al sistema de barra de experiencia nativo de Minecraft, proporcionando un indicador visual de progreso.

Aplicaci√≥n de Atributos: Al subir de Nivel Principal, el LevelingManager llama a statManager.getAttributeApplier() para que se actualicen inmediatamente los atributos f√≠sicos de Bukkit (Vida M√°xima, Da√±o, Velocidad).

Beneficios de Habilidad
El m√©todo getSkillLevelUpMessage proporciona feedback espec√≠fico al jugador:

Herrer√≠a: Mayor durabilidad y estad√≠sticas de ataque en el equipo crafteado.

Sastrer√≠a: Mayor probabilidad de obtener mejores bonificaciones de defensa y velocidad en las armaduras.

Alquimia: Un aumento del 0.5% por nivel en la efectividad de las pociones.

LevelingManager.java
=
Esta clase es el motor del sistema de progresi√≥n RPG, ubicada en la carpeta stats. Su prop√≥sito es gestionar la adici√≥n de experiencia, el escalado de niveles y la aplicaci√≥n de beneficios.

Principio de Coordinaci√≥n (Delegaci√≥n)
Dado que la arquitectura del proyecto divide la l√≥gica en clases especializadas, LevelingManager opera bajo la coordinaci√≥n del StatManager para mantener la consistencia y la limpieza:

Acceso a Stats: Obtiene el RPGStats del jugador a trav√©s de statManager.getStats().

Actualizaci√≥n de Atributos (Bukkit): Llama a statManager.getAttributeApplier().applyPlayerAttributes() al subir de nivel principal.

Persistencia (Guardado): Resuelve el problema de la firma de guardado delegando la tarea. Llama a statManager.savePlayerStats(player.getUniqueId()). Esto evita que LevelingManager tenga que preocuparse por la conversi√≥n de UUID a PlayerData, manteniendo la capa de persistencia aislada en el StatManager.

Mecanismos de Progresi√≥n
1. Escalado de Experiencia
   La experiencia requerida para subir de nivel utiliza un sistema de crecimiento exponencial con un factor de escalado de 1.20. Esto asegura que el esfuerzo requerido aumente progresivamente, manteniendo el juego desafiante a niveles altos.

2. Subida de Nivel y Recompensas
   Nivel Principal (MAIN): Al subir de nivel, el jugador recibe 3 Puntos de Atributo para gastar en stats principales (Fuerza, Vitalidad, etc.). El cambio desencadena una actualizaci√≥n inmediata de los atributos de Minecraft (MAX_HEALTH, ATTACK_DAMAGE, MOVEMENT_SPEED).

Habilidades Secundarias: El jugador es notificado del nuevo nivel y su beneficio directo:

Herrer√≠a: Mayor calidad y durabilidad en armas/herramientas.

Sastrer√≠a: Mejora las bonificaciones de armaduras.

Alquimia: Otorga un aumento del 0.5% por nivel en la efectividad de las pociones.

3. Sincronizaci√≥n con Minecraft
   La funci√≥n updatePlayerExpBar es crucial, ya que traduce la progresi√≥n interna del sistema RPG a la barra de experiencia nativa de Minecraft, proporcionando feedback visual en tiempo real del progreso del Nivel Principal.

MenuBuilder.java
=
Esta clase es la responsable de construir y gestionar la Interfaz de Usuario (UI) para el sistema de atributos RPG. Act√∫a como la capa de presentaci√≥n que traduce los valores num√©ricos internos del jugador en informaci√≥n legible y din√°mica dentro de un inventario de Minecraft.

Arquitectura y Delegaci√≥n
MenuBuilder no contiene l√≥gica de juego ni c√°lculos complejos; en su lugar, delega estas responsabilidades a las clases de utilidad para asegurar una arquitectura limpia:

StatManager: Se usa para obtener el objeto RPGStats actual del jugador.

AttributeApplier: Utilizado para calcular y mostrar el valor total de atributos de Bukkit, como la Vida M√°xima.

LevelingManager: Se encarga de proporcionar las f√≥rmulas necesarias para calcular la experiencia total requerida y el progreso porcentual de las Habilidades Secundarias.

Estructura del Men√∫ y Atributos
El men√∫ principal de estad√≠sticas es un inventario de 27 slots que presenta dos categor√≠as clave: Atributos Principales (mejorables) y Habilidades Secundarias (de progresi√≥n pasiva).

Atributos Principales (Mejorables)
Cada √≠tem de atributo muestra el valor actual y el valor proyectado en el siguiente nivel.

Agilidad: Muestra el valor de Evasi√≥n (%) actual (Dodge Chance), calculada con 0.2% por punto de Agilidad.

Defensa Total: Muestra la Reducci√≥n Plana/Punto (Defensa F√≠sica) que el jugador posee. Se ha eliminado toda referencia a la Defensa M√°gica.

Fuerza & Vida M√°xima: Muestran el da√±o base y la vida total, respectivamente.

Estamina y Regeneraci√≥n: Muestran los puntos m√°ximos de Estamina y su recuperaci√≥n por segundo (Puntos/s).

Velocidad de Recolecci√≥n: Muestra los porcentajes de Velocidad de Minado y Talado.

Habilidades Secundarias
Se presentan con su nivel actual, la experiencia total y el porcentaje de progreso hasta el siguiente nivel.

Herrer√≠a: Mejora la calidad del equipo crafteado.

Sastrer√≠a: Mejora las armaduras de tela y cuero.

Alquimia: Aumenta la efectividad de las pociones.

Interacci√≥n y Lore Din√°mico
El m√©todo createStatLore es fundamental. Genera el texto descriptivo (Lore) para cada √≠tem, adapt√°ndose al stat espec√≠fico (mostrando porcentajes, unidades como HP/s, etc.).

El mensaje "Click Izquierdo: Subir Nivel" solo es visible si el jugador tiene Puntos de Habilidad disponibles (unspentPoints > 0), guiando la acci√≥n del jugador de forma clara.

RegenerationScheduler.java
=
Esta clase fundamental gestiona la l√≥gica de regeneraci√≥n de vida (Health) y gesti√≥n de estamina (Stamina) para todos los jugadores en l√≠nea. Opera mediante una tarea programada peri√≥dica para aplicar cambios de manera eficiente.

Mecanismos Principales
El scheduler se ejecuta cada REGEN_TICK_RATE (10 ticks, o 0.5 segundos), asegurando que los c√°lculos por segundo se distribuyan uniformemente.

1. Gesti√≥n de Estamina
   La Estamina se gestiona con una l√≥gica estricta que castiga el agotamiento total:

Gasto por Sprint: La estamina disminuye cuando el jugador est√° corriendo (player.isSprinting()) a una tasa constante (staminaCostPerTick).

Regeneraci√≥n: Solo ocurre cuando el jugador no est√° corriendo y no est√° en cooldown. La tasa es din√°mica, basada en el stat de Regeneraci√≥n de Estamina del jugador.

Cooldown por Agotamiento: Si la estamina llega a cero, el jugador entra en un estado de cansancio (STAMINA_COOLDOWN_SECONDS).

Se aplica un debuff de lentitud (SLOWNESS).

El sprint se interrumpe y se bloquea durante el cooldown.

Se muestra un mensaje al jugador (ActionBar) notificando el agotamiento.

Visualizaci√≥n: Se delega la actualizaci√≥n visual de la estamina al StaminaBossBarManager.

2. Regeneraci√≥n de Vida (Health)
   La recuperaci√≥n de vida sigue un proceso m√°s simple, escalando con el stat de Regeneraci√≥n de Vida del jugador:

Tasa: La vida aumenta a la tasa definida por RPGStats.getHealthRegenPerSecond(), distribuida por tick.

Condici√≥n: La vida solo se regenera si el jugador no est√° corriendo (!isSprinting), premiando a los jugadores que detienen la acci√≥n para descansar.

Sincronizaci√≥n: La vida actual se sincroniza con el objeto RPGStats y el ScoreboardManager es notificado para actualizar cualquier pantalla.

Control de la Tarea
startRegenScheduler(): Inicializa el BukkitRunnable si a√∫n no est√° activo, asegurando que solo haya una tarea de regeneraci√≥n ejecut√°ndose.

stopRegenScheduler(): Cancela la tarea programada, esencial para el apagado seguro del plugin.


StaminaBossBarManager.java
=
Esta clase de utilidad es la responsable exclusiva de la presentaci√≥n visual de la Estamina del jugador utilizando el sistema nativo de BossBar de Minecraft a trav√©s de la API de Kyori Adventure.

Funcionalidad Central
El gestor opera directamente sobre un mapa de BossBars proporcionado por el coordinador (StatManager), garantizando la centralizaci√≥n de los datos.

1. Actualizaci√≥n Din√°mica (updateStaminaBossBar)
   El m√©todo principal se llama peri√≥dicamente desde el RegenerationScheduler para mantener la BossBar sincronizada con la Estamina actual del jugador (RPGStats):

C√°lculo del Progreso: La barra muestra el porcentaje (float) de Estamina Actual respecto a la Estamina M√°xima.

Gradiente de Color: El color de la barra cambia din√°micamente seg√∫n el nivel de Estamina:

Verde: Estamina alta (m√°s del 50%).

Amarillo: Estamina media (entre 25% y 50%).

Rojo: Estamina baja (menos del 25%), alertando al jugador del riesgo de agotamiento.

Sincronizaci√≥n: El texto del nombre de la BossBar (que muestra el valor num√©rico "Actual / M√°ximo") se actualiza y su color se sincroniza con el color de la barra misma para una mejor coherencia visual.

2. Gesti√≥n de la Barra
   Creaci√≥n: Si no existe una BossBar para el jugador, se crea una nueva, se asigna al jugador (player.showBossBar()) y se almacena en el mapa.

Remoci√≥n (removeStaminaBossBar): Se utiliza cuando el jugador se desconecta o al detener el plugin, asegurando que la barra se oculte correctamente (player.hideBossBar()) y se elimine del mapa de seguimiento.

StatListeners.java: Puente de Eventos RPG
=
Esta clase implementa el interfaz Listener de Bukkit y sirve como el puente crucial entre los eventos de juego nativos de Minecraft y la l√≥gica interna de tu sistema RPG. Centraliza la respuesta a acciones del jugador relacionadas con la vida, estamina y movimientos.

Responsabilidades Clave
1. Control de Sprint y Estamina (onPlayerToggleSprint)
   Bloqueo de Seguridad: Si un jugador intenta iniciar un sprint y su Estamina Actual es inferior a 5.0, el evento se cancela. Esto impide que el jugador se agote inmediatamente y garantiza que siempre tenga un peque√±o colch√≥n de estamina para movimientos b√°sicos o emergencias.

2. Muerte del Jugador (onPlayerDeath)
   Al morir un jugador, la clase se encarga de limpiar cualquier estado residual del sistema RPG para evitar bugs al reaparecer:

Se utiliza StaminaBossBarManager para ocultar y eliminar la barra de Estamina.

Se elimina cualquier debuff de Lentitud (SLOWNESS) aplicado por el cooldown de Estamina.

Se limpia el estado de cooldown de Estamina (staminaCooldowns.remove) para que la regeneraci√≥n pueda comenzar inmediatamente al reaparecer.

3. Reestablecimiento al Reaparecer (onPlayerRespawn)
   Al reaparecer, los stats de Minecraft deben sincronizarse con los valores del sistema RPG:

Ejecuci√≥n con Delay: La l√≥gica se ejecuta con un delay de un tick (runTaskLater(..., 1L)) para asegurar que el proceso de respawn de Bukkit haya finalizado antes de manipular los atributos.

Re-aplicaci√≥n de Atributos: Se llama a AttributeApplier.applyPlayerAttributes() para garantizar que el valor de Vida M√°xima de Minecraft se ajuste correctamente al valor del sistema RPG.

Vida y Estamina Completas: El jugador es curado completamente (player.setHealth(maxHealth)) y la Estamina se restaura a su valor m√°ximo, y la BossBar se actualiza y se muestra de nuevo.

Esta clase es esencial para la robustez y la experiencia de usuario, asegurando que el estado del jugador se mantenga limpio y coherente durante las transiciones de juego.

AttributeType.java: Definici√≥n de Atributos RPG
=
Esta enumeraci√≥n (enum) es un componente fundamental del sistema RPG, ya que define un cat√°logo estricto de todos los atributos que pueden existir en el juego. Su prop√≥sito principal es estandarizar los stats que pueden ser aplicados a jugadores, √≠tems (armas/armaduras) o consumibles.

Estructura
Cada constante de la enumeraci√≥n almacena dos propiedades esenciales para su uso en la presentaci√≥n del juego:

displayName: El nombre legible y formateado que se muestra al usuario (ej. en el lore de un √≠tem).

color: El color de ChatColor asociado, utilizado para mantener la coherencia visual del atributo en men√∫s y descripciones.

Categor√≠as de Atributos
La lista actual de atributos se divide l√≥gicamente en categor√≠as para facilitar el mantenimiento y la lectura:

‚öîÔ∏è Combate y Estad√≠sticas Base
STRENGTH (Fuerza): Da√±o de ataque base. (Rojo)

AGILITY (Agilidad): Contribuye a la evasi√≥n y el movimiento. (Amarillo)

DEFENSE (Defensa): Reducci√≥n de da√±o f√≠sico plana. (Azul)

ATTACK_SPEED (Velocidad de Ataque): Frecuencia con la que el jugador puede atacar. (Cian)

ATTACK_RANGE (Alcance): Distancia efectiva del ataque. (Morado Claro)

‚ú® Utilidad
HEALTH_REGEN (Regeneraci√≥n de Vida): Tasa de recuperaci√≥n de HP por segundo. (Verde Oscuro)

CRITICAL_CHANCE (Probabilidad Cr√≠tica): Posibilidad de infligir da√±o extra. (Dorado)

üî® Herrer√≠a (Crafting)
DURABILITY_BONUS (Bonus de Durabilidad): Ejemplo de un stat que podr√≠a ser a√±adido a √≠tems crafteados con la habilidad de Herrer√≠a. (Blanco)

Esta clase garantiza que cualquier nuevo atributo a√±adido al sistema se defina en un √∫nico lugar, manteniendo la consistencia de los nombres y colores en toda la aplicaci√≥n.

MonsterListener.java: Motor de Combate y Nivelaci√≥n de Mobs
=
Esta clase es un Listener central en el sistema RPG, encargada de la inicializaci√≥n de atributos, la gesti√≥n de la dificultad en combate, y la recompensa de experiencia para los monstruos. Act√∫a como el puente entre los eventos de spawn y da√±o de Bukkit y la l√≥gica personalizada de nivelaci√≥n RPG.

1. Asignaci√≥n de Nivel y Atributos
   El m√©todo onCreatureSpawn garantiza que todos los mobs vivientes (LivingEntities) que aparecen en el mundo sean procesados para obtener atributos RPG.

Exclusiones: Los jugadores y los mobs creados por Spawners (que por defecto se asumen como Nivel 1) son ignorados o tratados de manera especial para evitar el escalado en √°reas controladas.

Nivel Din√°mico: El nivel del monstruo se determina din√°micamente llamando a WorldDifficultyManager.getSpawnLevel(), lo que permite que el nivel del mob dependa de la ubicaci√≥n del spawn.

Inicializaci√≥n: Se crea un objeto RPGMonster, se le asigna el nivel y se llama a rpgMob.applyAttributes() para modificar sus atributos base (como vida m√°xima).

Metadata: El objeto RPGMonster se guarda directamente en la metadata de la entidad bajo la clave RPG_METADATA_KEY, garantizando que sus stats persistan durante toda su vida.

Visualizaci√≥n: Se aplica una etiqueta de nombre (NameTag) que muestra el nivel del mob: [Lv. X] NombreOriginal.

2. L√≥gica de Combate: Aplicaci√≥n de Defensa
   El handler onEntityDamage intercepta el da√±o para aplicar la defensa personalizada del mob:

Reducci√≥n de Da√±o: Si la entidad da√±ada tiene metadata RPGMonster, se recupera su valor de DefenseReduction (Defensa).

F√≥rmula: El da√±o final es el resultado de restar directamente la defensa del da√±o original: Da√±o Final = MAX(0.1, Da√±o Original - Defensa). Se asegura un da√±o m√≠nimo de 0.1 para evitar combates estancados.

Feedback: Si el atacante es un jugador, se le muestra un ActionBar detallando el da√±o original, la reducci√≥n aplicada por defensa, y el da√±o final, mejorando la inmersi√≥n.

3. Recompensa de Experiencia (EXP)
   Al morir un mob, onEntityDeath gestiona la recompensa de experiencia:

Bloqueo Vanilla: La experiencia vanilla (event.setDroppedExp(0)) se bloquea por completo.

Recompensa Custom: El valor de la EXP a otorgar (rpgMob.getExpReward()) es recuperado del objeto RPGMonster.

Sistema Centralizado: La EXP es otorgada al jugador que mat√≥ al mob (killer) utilizando plugin.getXPManager().addExp(), asegurando que la nivelaci√≥n se gestione de forma unificada.

Limpieza: Se elimina la metadata RPG_METADATA_KEY del mob para una limpieza adecuada de la memoria.

ParryManager.java: Sistema de Esquivar (Dodge)
=
Esta clase implementa un sistema de habilidad activa, permitiendo a los jugadores esquivar o bloquear el da√±o inminente utilizando la tecla Shift (Sneak). La funcionalidad se basa en otorgar un breve per√≠odo de invulnerabilidad que requiere precisi√≥n y est√° limitado por un cooldown.
Flujo de Activaci√≥n
Evento de Agacharse (onPlayerToggleSneak): Solo se activa cuando el jugador comienza a agacharse.

Chequeo de Cooldown: Si el jugador est√° en cooldown, se le informa a trav√©s de la ActionBar con el tiempo restante.

Activaci√≥n (activateDodge): Si el cooldown est√° listo, el jugador entra en el estado isInvulnerable = true y se inicia un cooldown de 3 segundos.

Finalizaci√≥n: Un BukkitRunnable programado para 16 ticks (0.8s) termina el estado de invulnerabilidad y notifica al jugador.

Prevenci√≥n de Da√±o (onEntityDamage)
Este handler intercepta todos los eventos de da√±o dirigidos al jugador.

Si el flag isInvulnerable es true, el evento de da√±o se cancela (event.setCancelled(true)) y el jugador recibe una notificaci√≥n de √©xito en la ActionBar.

Almacenamiento y Limpieza
Se utilizan dos mapas HashMap (cooldowns y isInvulnerable) para gestionar el estado de cada jugador por su UUID. El evento onPlayerQuit asegura que la informaci√≥n del jugador se elimine de ambos mapas al desconectarse, previniendo fugas de memoria y bugs de estado.

QualityUtility.java: Gesti√≥n de Calidad de √çtems
=
Esta clase es un utility central que encapsula toda la l√≥gica relacionada con la calidad de los √≠tems crafteados (Armas, Armaduras y Herramientas) en el sistema RPG. Define los rangos de calidad, sus beneficios inherentes y la f√≥rmula para calcular la calidad obtenida.

1. Definici√≥n de Calidades
   Se utilizan LinkedHashMap para definir las calidades en orden estricto, desde Com√∫n hasta M√≠tico. Cada calidad tiene beneficios espec√≠ficos:

Calidad	Color	Durabilidad Inicial	Atributos Aleatorios
Com√∫n	Gris	20%	1
Raro	Azul	40%	2
√âpico	P√∫rpura	60%	3
Legendario	Dorado	80%	4
M√≠tico	Rojo	100%	5

Exportar a Hojas de c√°lculo
Durabilidad Inicial: Representa el porcentaje de durabilidad con el que se genera el √≠tem, lo cual significa que un √≠tem M√≠tico comienza con la durabilidad completa.

Atributos Aleatorios: Indica cu√°ntos stats RPG aleatorios se a√±adir√°n al lore del √≠tem.

2. L√≥gica de C√°lculo (calculateQuality)
   El m√©todo calculateQuality es el coraz√≥n del sistema, determinando la calidad final del √≠tem a trav√©s de una f√≥rmula de √©xito progresivo:

Probabilidad Base de √âxito (successChance): Se calcula en funci√≥n del skillLevel (nivel de habilidad del jugador en Herrer√≠a o Sastrer√≠a) en relaci√≥n con la difficultyLevel (dificultad del material, ej. Netherite es m√°s dif√≠cil que el Hierro).

Un nivel de habilidad mucho mayor que la dificultad aumenta la successChance hacia el 100%.

Existe un m√≠nimo de 5% para la successChance.

Prueba de Calidad Secuencial: El sistema itera a trav√©s de las calidades (Com√∫n, Raro, √âpico...). Para cada calidad superior, la successChance se penaliza.

El jugador debe superar una prueba aleatoria para "pasar" al siguiente nivel de calidad.

La calidad final es la m√°s alta que el jugador logr√≥ superar con √©xito.

3. Utilidades de Presentaci√≥n
   La clase tambi√©n proporciona m√©todos helper para asegurar la coherencia visual en toda la aplicaci√≥n:

getNamedColorForQuality y getChatColorForQuality: Devuelven los c√≥digos de color de Kyori Adventure y Bukkit, respectivamente, para aplicar formato al nombre y al lore del √≠tem.

getQualityFromItem: Permite leer la calidad de un √≠tem existente inspeccionando la primera palabra de su nombre de visualizaci√≥n, lo cual es esencial para el manejo de √≠tems ya crafteados.

RPGItemGenerator.java: F√°brica de √çtems RPG
=
Esta clase de utilidad es responsable de tomar un √≠tem base y transformarlo en un √≠tem RPG completo, asign√°ndole una calidad, un nivel y un conjunto de atributos aleatorios. Es el punto de control para la inyecci√≥n de la l√≥gica RPG en el crafteo y la generaci√≥n de loot.

Flujo de Generaci√≥n (generateRPGItem)
El proceso de generaci√≥n sigue cuatro pasos esenciales, asegurando que todos los par√°metros del √≠tem sean coherentes:

Determinaci√≥n de Calidad: Llama a QualityUtility.calculateQuality() para obtener la calidad final ("Raro", "Legendario", etc.) basada en la habilidad del crafteador y la dificultad del material.

Determinaci√≥n de Nivel: Llama a determineItemLevel() para asignar un nivel al √≠tem, que nunca supera el nivel de habilidad del crafteador.

Generaci√≥n de Atributos: Llama a generateAttributes() para seleccionar una cantidad de stats aleatorios dictada por la calidad, y asignarles un valor limitado por el nivel del √≠tem.

Personalizaci√≥n: Llama a customizeItem() para aplicar la metadata visual (nombre, color, lore).

L√≥gica de Balance
Nivel del √çtem (determineItemLevel)
El nivel del √≠tem se genera con un sesgo estad√≠stico hacia el nivel de habilidad del crafteador (crafterLevel).

El nivel m√≠nimo es 25% del nivel del crafteador, asegurando que el √≠tem sea siempre relevante.

El uso de Math.sqrt(random.nextDouble()) sesga la distribuci√≥n de probabilidad hacia valores m√°s altos, resultando en que la mayor√≠a de los √≠tems generados est√©n muy cerca del nivel m√°ximo del jugador.

Potencia de Atributos (generateAttributes)
La potencia de los stats aleatorios est√° rigurosamente controlada para evitar √≠tems overpowered:

L√≠mite M√°ximo: El valor del atributo es proporcional al nivel del √≠tem (ej. 0.1 * itemLevel). Un √≠tem de nivel 100 tendr√° un potencial de stats mucho mayor que uno de nivel 10.

Selecci√≥n: La cantidad de atributos seleccionados es determinada por la calidad (1 para Com√∫n, 5 para M√≠tico), utilizando QualityUtility.

Rango: El valor final del atributo se genera aleatoriamente en el rango [1.0, MaxValue].

Presentaci√≥n (Visual)
Nombre: El nombre del √≠tem se formatea usando la API de Kyori Adventure, mostrando la calidad en color y el nombre base en may√∫sculas (ej: [√âPICO] ESPADA DE DIAMANTE).

Lore: Se a√±ade el Nivel del √çtem y la Habilidad utilizada. Los atributos aleatorios se listan utilizando el color asociado a cada AttributeType.

NOTA IMPORTANTE: Actualmente, el nivel y los atributos se guardan solo en el lore (texto). Para la persistencia (supervivencia a reinicios y recargas), es crucial implementar el guardado de estos datos en los Persistent Data Containers (PDC) del ItemMeta.

RPGMonster.java: Modelo de Monstruo Escalado
=
Esta clase fundamental act√∫a como el modelo de datos y el motor de escalado para todos los monstruos en el juego. Su prop√≥sito es calcular y aplicar las estad√≠sticas de combate de un mob bas√°ndose en su nivel asignado, utilizando f√≥rmulas de escalado robustas.

F√≥rmulas de Escalado (Robustez)
Para evitar que los mobs de alto nivel sean triviales, la mayor√≠a de los stats clave utilizan una combinaci√≥n de escalado lineal y cuadr√°tico.

Stat=Base+(Lineal√óNivel)+(Cuadr
a
Àä
tico√óNivel
2
)
Escalado Cuadr√°tico: El uso de factores cuadr√°ticos (* \text{LvlDiff}^2) asegura que la Vida M√°xima y el Da√±o de Ataque se disparen a niveles altos (ej. Nivel 100), manteniendo la dificultad relevante para jugadores de end-game.

Estad√≠stica	Escalado	Impacto
Vida M√°xima	Cuadr√°tico	Determina la durabilidad del mob.
Da√±o de Ataque	Cuadr√°tico	Asignado al atributo ATTACK_DAMAGE de Minecraft.
Reducci√≥n de Defensa	Cuadr√°tico	Un valor plano que se resta del da√±o recibido.
Resistencia al Empuje	Lineal	Escala hasta un m√°ximo de 1.0 (100%), dificultando el control de crowd control a niveles altos.
Recompensa de EXP	Exponencial	Crece r√°pidamente con el nivel (FACTOR^{Nivel-1}) para que la recompensa justifique el riesgo.

Exportar a Hojas de c√°lculo
Aplicaci√≥n de Atributos (applyAttributes)
El m√©todo applyAttributes es el punto donde la l√≥gica RPG se inyecta en la entidad de Minecraft:

Vida M√°xima: Se establece el Attribute.MAX_HEALTH y se cura a la entidad por completo (entity.setHealth(this.maxHealth)).

Da√±o de Ataque: Se establece el Attribute.ATTACK_DAMAGE.

Resistencia al Empuje: Se establece el Attribute.KNOCKBACK_RESISTANCE.

Las estad√≠sticas como la Reducci√≥n de Defensa se almacenan internamente y se aplican en la clase MonsterListener cuando la entidad recibe da√±o, lo que permite una f√≥rmula de reducci√≥n personalizada.

RPGStats.java: Almac√©n de Estad√≠sticas de Jugador
=
Esta clase es el modelo de datos principal que almacena toda la progresi√≥n y personalizaci√≥n de un jugador en el sistema RPG. Est√° dise√±ado para ser persistente (guardado y cargado por el UserDataManager) y centraliza las f√≥rmulas de c√°lculo de atributos y recursos.

Estructura de Progresi√≥n
La clase se organiza en tres secciones principales de progresi√≥n:

1. Progresi√≥n Principal
   level / totalExperience: Nivel principal del jugador y EXP acumulada.

unspentPoints: Puntos de habilidad disponibles para ser invertidos.

Cada subida de nivel principal otorga 1 punto (addExpTotal).

L√≥gica de EXP: El m√©todo addExpTotal utiliza un bucle while y la f√≥rmula getExpForNextLevel para procesar correctamente la EXP, asegurando que se suban m√∫ltiples niveles si la EXP ganada es excesiva.

2. Habilidades Secundarias (Skills)
   skillLevels / skillExperience: Dos mapas que almacenan el nivel y la EXP individual de habilidades como Herrer√≠a (BLACKSMITHING), Sastrer√≠a (TAILORING), etc.

M√©todo addExp(AbilityType, ...): Este m√©todo es el punto de entrada recomendado para sumar EXP a una habilidad secundaria, ya que gestiona autom√°ticamente las notificaciones y las subidas de nivel (incluso m√∫ltiples) hasta el Nivel 100.

3. Atributos Invertibles (Stats)
   Estos campos almacenan la cantidad de puntos que el jugador ha invertido directamente usando unspentPoints.

Atributo	Foco	Factor de Conversi√≥n	Funci√≥n
statHealth	Vida M√°xima	+1.0 HP por punto	Aumenta la vida base de Minecraft.
statStrength	Da√±o	+0.5 Da√±o por punto	Bonus de da√±o de ataque.
statDefense	Defensa	+0.1 Reducci√≥n por punto	Reducci√≥n fija de da√±o recibido.
statStaminaMax	Estamina M√°xima	+20.0 por punto	Aumenta el recurso de Estamina.
statHealthRegen	Regen. Vida	+0.05 HP/s por punto	Aumenta la regeneraci√≥n pasiva.

Exportar a Hojas de c√°lculo
L√≥gica de Recursos (Vida y Estamina)
Los recursos del jugador se gestionan de forma personalizada:

Vida M√°xima (getMaxHealth): Calcula la vida m√°xima efectiva sumando la BASE_HEALTH (20.0) m√°s los puntos invertidos.

Vida/Estamina Actual (setCurrent...): Los setters aseguran que el valor de la vida o estamina actual nunca exceda el m√°ximo y nunca caiga por debajo de cero.

consumeStamina: Proporciona un m√©todo seguro para gastar Estamina, verificando primero que el recurso est√© disponible.

Integridad y Robustez
Constructores: El constructor por defecto inicializa las habilidades clave y establece currentHealth y currentStamina a sus valores m√°ximos, evitando null o estados inconsistentes.

M√©todos increaseStatX(): Los mutators de atributos primero llaman a spendPoint(), garantizando que solo se pueda mejorar un stat si el jugador tiene puntos disponibles.

Recarga de HP/Estamina: Al mejorar statHealth o statStaminaMax, se llama a setCurrentHealth/Stamina(getMax...), llenando el recurso por completo, lo cual es una buena pr√°ctica de experiencia de usuario.

SpawnZone.java: Definici√≥n de Zonas de Monstruos
=
Esta clase es un modelo de datos que define una regi√≥n rectangular en el mundo de juego, actuando como un spawner virtual de monstruos. Centraliza las reglas sobre qu√© monstruos aparecen, con qu√© niveles y bajo qu√© condiciones.

Estructura de Datos
La clase almacena dos conjuntos principales de datos:

Par√°metros de √Årea (Bounding Box):

worldUID: El ID √∫nico del mundo para garantizar la unicidad.

x1, y1, z1, x2, y2, z2: Las coordenadas de las esquinas del cubo. El constructor asegura que los valores se guarden como min y max usando Math.min y Math.max para simplificar la l√≥gica de verificaci√≥n espacial.

Par√°metros de Spawning:

minLevel / maxLevel: El rango de niveles RPG que tendr√°n los monstruos generados en esta zona.

mobTypes: Una lista de enums EntityType que especifica qu√© mobs puede generar esta zona (ej. ZOMBIE, SKELETON).

maxMobs: El l√≠mite de mobs que pueden existir simult√°neamente en esta zona.

spawnDelayTicks: La frecuencia con la que un gestor de spawner debe intentar generar un nuevo mob en esta zona (ej. 20 ticks = 1 segundo).

Funcionalidad Clave (contains)
El m√©todo contains(Location) es esencial. Permite que el sistema verifique r√°pidamente si un jugador, un monstruo, o un punto de generaci√≥n potencial, se encuentra dentro de los l√≠mites de esta zona.

La verificaci√≥n es robusta, comprobando primero que el worldUID coincida antes de realizar la verificaci√≥n de coordenadas x, y y z.

Uso
Esta clase est√° dise√±ada para ser le√≠da desde archivos de configuraci√≥n (YAML o JSON) y gestionada por un SpawnZoneManager global, que luego la utiliza un MobSpawnListener o un scheduler de tareas para generar mobs.

StatManager.java: Coordinador de Atributos RPG
=
La clase StatManager act√∫a como el coordinador principal (patr√≥n Facade) de todo el subsistema de estad√≠sticas RPG. Su funci√≥n es centralizar la inicializaci√≥n, la comunicaci√≥n entre subm√≥dulos y el acceso a los datos persistentes del jugador.

Cualquier otra clase de tu plugin debe interactuar con la l√≥gica RPG solo a trav√©s del StatManager, lo que reduce el acoplamiento y facilita la escalabilidad.

Responsabilidades Clave
Inicializaci√≥n de M√≥dulos: En el constructor, StatManager inicializa y enlaza todos los managers de estad√≠sticas:

LevelingManager

AttributeApplier (que maneja la aplicaci√≥n de HP/Da√±o/Velocidad de forma persistente en los atributos de Minecraft).

StaminaBossBarManager (gestiona la barra de estamina).

RegenerationScheduler (la tarea programada que actualiza peri√≥dicamente Vida/Estamina/Atributos).

MenuBuilder (crea la interfaz de usuario para gastar puntos).

Gesti√≥n de Recursos Compartidos: Mantiene los mapas de estado (staminaBars, staminaCooldowns) que son accedidos por m√∫ltiples m√≥dulos.

Centralizaci√≥n de Datos (getStats): Proporciona un m√©todo seguro y √∫nico para obtener el objeto RPGStats de un jugador desde el UserDataManager, incluyendo una l√≥gica de fallback robusta en caso de fallos de carga.

Control de Comandos: Implementa el comando /stats o /atributos para dar acceso directo al men√∫ de inversi√≥n de puntos.

Persistencia: Define las NamespacedKey (healthKey, damageKey, speedKey) utilizadas por AttributeApplier para garantizar la persistencia de los modificadores de atributos a trav√©s de recargas.

Flujo de Trabajo
Al iniciar el plugin, se crea una instancia de StatManager.

El StatManager inicia el RegenerationScheduler, el cual se ejecuta peri√≥dicamente (cada tick o cada pocos ticks).

El scheduler llama a AttributeApplier.applyPlayerStats() para actualizar el HP/Da√±o/Velocidad del jugador bas√°ndose en los puntos invertidos en RPGStats.

El scheduler tambi√©n llama a StaminaBossBarManager para actualizar visualmente la estamina del jugador y a su propia l√≥gica para regenerar Vida/Estamina.

Cuando un jugador ejecuta /stats, el StatManager llama a MenuBuilder.openStatMenu() para construir la interfaz.

El StatManager es la columna vertebral que mantiene todo tu sistema de estad√≠sticas sincronizado y activo.

WorldDifficultyManager.java: Motor de Dificultad Global
=
Esta clase gestiona la dificultad de los monstruos a nivel mundial, bas√°ndose en la estrategia de un escalado lento pero constante atado al tiempo real, complementado con zonas de nivel fijo definidas por la administraci√≥n.

Estrategia de Balance Ajustada
La dificultad se divide en dos categor√≠as, lo que garantiza el control del administrador sin eliminar la progresi√≥n del servidor.

Tipo de Monstruo	Mecanismo de Nivel	Comportamiento
Global (Spawn natural)	Nivel Base Global (escrito en config) + Variaci√≥n Aleatoria	Su nivel aumenta 1 vez cada 24 horas reales. Son el desaf√≠o progresivo del mundo.
Fijo (Dentro de SpawnZone)	Nivel Min/Max definido en la zona.	Su nivel nunca cambia por el tiempo. Ideal para zonas de farmeo o inicio.

Exportar a Hojas de c√°lculo
L√≥gica de Escalado Temporal
Tasa: El nivel base global sube 1 nivel cada 1 d√≠a real (DAYS_PER_LEVEL_INCREASE = 1).

Implementaci√≥n: Una tarea as√≠ncrona (startDailyChecker) se ejecuta exactamente cada 24 horas para incrementar el contador serverDays y aplicar la subida de globalBaseLevel.

Notificaci√≥n: Al subir el nivel global, se env√≠a un mensaje de broadcast a todos los jugadores para avisarles del aumento de dificultad.

C√°lculo de Nivel (getSpawnLevel)
Este m√©todo determina el nivel final del monstruo en el punto de aparici√≥n:

Prioridad: Primero verifica si la Location est√° dentro de cualquier SpawnZone. Si lo est√°, el nivel se extrae del rango fijo de la zona.

Dificultad Global: Si no est√° en una zona definida, el nivel se calcula como:

Nivel¬†Final=Random(GlobalBaseLevel,GlobalBaseLevel+LEVEL_VARIANCE)

Donde LEVEL_VARIANCE es un factor de 5 niveles, asegurando que siempre haya una peque√±a variaci√≥n de desaf√≠o.

Persistencia y Administraci√≥n
La clase es responsable de cargar y guardar la configuraci√≥n (globalBaseLevel y serverDays) para mantener la progresi√≥n del servidor.

Los m√©todos addZone y removeZone permiten la administraci√≥n por comandos para crear y modificar zonas de nivel fijo de manera sencilla y segura.

AttributeApplier.java: El Traductor de Atributos
=
Este componente es el puente cr√≠tico entre el sistema RPG personalizado de VendralyCore y el sistema de atributos nativos de Minecraft (Vida M√°xima, Da√±o y Velocidad de Movimiento). Su √∫nica responsabilidad es leer los puntos de estad√≠stica de un jugador y aplicarlos como modificadores de Bukkit.

Funci√≥n Principal: applyPlayerAttributes(Player)
Este m√©todo se invoca siempre que las estad√≠sticas de un jugador cambian, ya sea por una subida de nivel, equipamiento o al iniciar sesi√≥n. Sigue un proceso de tres pasos esencial para la estabilidad:

Obtenci√≥n de Datos: Obtiene el objeto RPGStats a trav√©s del StatManager, asegurando que estamos trabajando con la √∫nica fuente de verdad en memoria.

Limpieza: Ejecuta removeAttributeModifiers para eliminar todos los modificadores aplicados previamente por este plugin.

Aplicaci√≥n: Vuelve a aplicar la Vida M√°xima, el Da√±o de Ataque y la Velocidad de Movimiento, bas√°ndose en los valores actuales de RPGStats.

Mecanismo de Limpieza (1.21.8 Purpur)
El m√©todo removeAttributeModifiers utiliza la sintaxis m√°s moderna y eficiente para eliminar modificadores sin depender de m√©todos obsoletos (deprecated).

En lugar de usar el UUID, itera sobre la colecci√≥n de modificadores activos (damageAttr.getModifiers()) y utiliza el NamespacedKey (mod.getKey()) para identificar y eliminar solo los modificadores que pertenecen a VendralyCore. Esto garantiza que no haya duplicaci√≥n de efectos al recalcular atributos.

Mecanismo de Aplicaci√≥n de Stats
Vida M√°xima (MAX_HEALTH): El valor calculado de RPGStats.getMaxHealth() se aplica directamente al atributo con healthAttr.setBaseValue(). Esto sobrescribe cualquier valor base anterior.

Da√±o (ATTACK_DAMAGE) y Velocidad (MOVEMENT_SPEED): Para estos, se crea un nuevo AttributeModifier en cada rec√°lculo. Se utiliza el constructor no-obsoleto de 4 argumentos (NamespacedKey, valor, operaci√≥n, UUID) y el valor del modificador se escala directamente con los puntos de Fuerza y Velocidad del jugador.

XPManager.java: Gesti√≥n de Progresi√≥n y Nivel
=
La clase XPManager es el motor central de la progresi√≥n de los jugadores. Se encarga de calcular la curva de experiencia, procesar la adici√≥n de XP, gestionar las subidas de nivel y sincronizar el progreso con la barra de experiencia nativa de Minecraft.

Curva de Nivelaci√≥n
La dificultad est√° definida por dos constantes clave:

BASE_XP (200): La experiencia base requerida para alcanzar el Nivel 2.

XP_MULTIPLIER (1.15): El factor de crecimiento exponencial que asegura que cada nivel sea un 15% m√°s dif√≠cil que el anterior, creando una curva de progresi√≥n sostenible a largo plazo.

El m√©todo getXPForNextLevel(int level) utiliza estos valores para calcular din√°micamente el requisito de experiencia total para subir al siguiente nivel.

Adici√≥n de Experiencia y Nivelaci√≥n (addXP)
Este es el m√©todo principal que se llama cuando un jugador realiza una acci√≥n que otorga experiencia (matar un monstruo, completar una misi√≥n, etc.).

Validaci√≥n de Datos: Accede al RPGStats del jugador a trav√©s del StatManager, manteniendo la Regla de la Fuente de Verdad (tal como se define en el README.md).

Procesamiento de Bucle: Utiliza un bucle while para garantizar que toda la cantidad de XP a√±adida sea procesada, permitiendo al jugador subir varios niveles de golpe si la cantidad de XP es muy grande.

Recompensas: Por cada nivel ganado, el jugador recibe STAT_POINTS_PER_LEVEL (1) punto de atributo no gastado, listo para ser asignado.

Sincronizaci√≥n Cr√≠tica: Tras una subida de nivel (leveledUp = true), se llama a statManager.getAttributeApplier().recalculateStats(player). Este paso es vital, ya que fuerza al sistema a aplicar instant√°neamente cualquier aumento de Vida, Da√±o o Velocidad resultante del nuevo nivel.

Interfaz de Usuario (updateVanillaXPBar)
La clase se encarga de que el progreso de nivelaci√≥n del sistema custom se refleje visualmente en el juego.

El m√©todo updateVanillaXPBar(Player) toma el nivel custom y el progreso de XP del RPGStats y lo traduce a los m√©todos de la API de Bukkit:

player.setLevel(level): Establece el n√∫mero flotante de nivel visible en el centro de la pantalla.

player.setExp(progress): Establece el progreso de la barra de experiencia verde, calculando la fracci√≥n de currentXP respecto al requiredXP. Esto ofrece al jugador una retroalimentaci√≥n visual inmediata sobre cu√°nto le falta para el siguiente hito.

ZoneSpawner.java: Sistema de Spawn de Zona
=
El ZoneSpawner es el sistema encargado de gestionar la aparici√≥n peri√≥dica y controlada de entidades hostiles dentro de √°reas geogr√°ficas predefinidas llamadas SpawnZone. Su objetivo es mantener una poblaci√≥n constante y equilibrada de mobs sin sobrecargar el servidor ni permitir un farmeo excesivo.

Mecanismo de Tarea Peri√≥dica
La l√≥gica principal se ejecuta mediante una tarea as√≠ncrona de Bukkit (BukkitRunnable) que se inicia con startSpawnerTask() y se detiene con stopSpawnerTask().

La tarea se repite cada 10 segundos (200 ticks), asegurando un ciclo de spawn constante y predecible. Esto evita picos de rendimiento y mantiene la dificultad fluida.

Control de Poblaci√≥n y Estabilidad
La estabilidad del servidor es prioritaria. Para ello, el spawner implementa un control estricto de la poblaci√≥n de mobs:

Conteo Activo (recalculateMobPopulation): Antes de intentar cualquier spawn, el sistema recorre todos los mundos y todas las entidades vivas, contando cu√°ntos mobs existen actualmente dentro de cada zona activa.

Mapa Sincronizado: El conteo se almacena en el mapa currentMobCount, que est√° sincronizado para garantizar la seguridad en un entorno multihilo.

L√≠mite de Zona (attemptSpawnInZone): Solo si el conteo actual es estrictamente menor al l√≠mite m√°ximo (zone.getMaxMobs()) definido para esa SpawnZone, se permite la aparici√≥n de un nuevo mob.

Este proceso de recuento peri√≥dico asegura que los mobs asesinados por jugadores o eliminados por la recolecci√≥n de basura del servidor sean reemplazados de manera eficiente hasta alcanzar el m√°ximo de la zona.

L√≥gica de Spawn Seguro
El m√©todo findSafeSpawnLocation(SpawnZone) es crucial para la jugabilidad, ya que resuelve el problema com√∫n del spawn en ubicaciones imposibles o peligrosas:

Busca aleatoriamente un punto dentro de los l√≠mites de la zona.

Verifica que el bloque de spawn sea no s√≥lido (generalmente aire).

Verifica que el bloque directamente debajo sea s√≥lido (el suelo).

Verifica que el bloque directamente encima tambi√©n sea no s√≥lido (espacio para que el mob respire).

Si despu√©s de m√∫ltiples intentos, no se encuentra un lugar seguro, el spawn es abortado, protegiendo al servidor de intentar spawns fallidos. El tipo de mob que aparece se selecciona de la lista definida en la SpawnZone de forma aleatoria.

NameTagManager.java: Gesti√≥n de Tags y Roles
=
El NameTagManager es el componente de la interfaz de usuario responsable de sincronizar el rol (Role) de un jugador con su apariencia visual dentro del juego. Su √∫nica funci√≥n es aplicar el prefijo y el color de un rol tanto al nombre que aparece encima de la cabeza (Name Tag) como al nombre en la lista de jugadores (Tablist).

Mecanismo Central: Scoreboard y Equipos
La aplicaci√≥n de prefijos se logra utilizando la API nativa de Scoreboard de Minecraft, que es el m√©todo est√°ndar y m√°s eficiente para este prop√≥sito:

Fuente del Rol: Al iniciar sesi√≥n o al actualizar un rol, el manager obtiene el Role del jugador a trav√©s del AuthManager (la fuente de verdad para los datos del jugador).

Creaci√≥n de Equipo: Se utiliza el Scoreboard principal del servidor para registrar un Team nuevo si a√∫n no existe un equipo para ese rol.

Configuraci√≥n: El prefijo formateado del rol (ej. [OWNER] ) se establece en el equipo (team.setPrefix(prefix)).

Asignaci√≥n: El jugador es a√±adido a este equipo (team.addEntry(player.getName())), lo que aplica autom√°ticamente el prefijo en su Name Tag para todos los dem√°s jugadores.

Prioridad y Orden de la Tablist
Para garantizar que los roles con mayor jerarqu√≠a (Owner, Dev, Mod) aparezcan correctamente ordenados al principio de la Tablist, se utiliza una convenci√≥n de nomenclatura basada en la prioridad:

Nombre de Equipo: El m√©todo getTeamName(Role) genera un nombre de equipo siguiendo el formato XX-ROLENAME (ej., 10-OWNER o 01-PLAYER).

Clasificaci√≥n: El prefijo num√©rico (XX) fuerza al Scoreboard de Bukkit a ordenar a los jugadores por el valor de prioridad, asegurando que los rangos m√°s importantes siempre sean visibles primero en la Tablist.

Soluci√≥n para Chat y Tablist
La clase maneja inteligentemente la distinci√≥n entre el nombre en la Tablist y el nombre que aparece en el chat para evitar la doble aparici√≥n de prefijos:

Tablist Completa: El m√©todo player.setPlayerListName(prefix + player.getName()) aplica intencionalmente el prefijo directamente al nombre de la lista, ya que el prefijo del Team no se aplica a la Tablist de forma nativa.

Chat Limpio: El m√©todo player.setDisplayName(player.getName()) es crucial. Si no se hiciera esto, el prefijo del Team se filtrar√≠a al chat, duplicando el prefijo que ya est√° manejando el plugin de chat. Al resetear el DisplayName, se asegura que el chat reciba solo el nombre limpio del jugador.

En resumen, el NameTagManager garantiza que la identidad visual del jugador sea precisa y consistente en todos los elementos de la interfaz de Minecraft, cumpliendo con los est√°ndares de dise√±o y estabilidad en la versi√≥n 1.21.8.

ScoreboardManager.java: Dashboard Din√°mico
=
El ScoreboardManager es el sistema de interfaz de usuario (UI) que centraliza la informaci√≥n crucial del jugador y del servidor en la pizarra lateral (sidebar). Su dise√±o robusto garantiza un rendimiento estable al manejar la compleja sincronizaci√≥n de datos as√≠ncronos (como el efectivo) con la actualizaci√≥n s√≠ncrona de la pizarra.

N√∫cleo del Sistema: Tarea de Actualizaci√≥n
La actualizaci√≥n de la pizarra se realiza mediante una tarea recurrente de Bukkit iniciada por startUpdateTask(). Esta tarea se ejecuta s√≠ncronamente cada 40 ticks (2 segundos) en el hilo principal del servidor, lo que es √≥ptimo para la estabilidad:

Actualizaci√≥n As√≠ncrona de Efectivo: Llama a updateAllCashBalancesAsync() para refrescar la cach√© de efectivo de los jugadores en un entorno as√≠ncrono.

Actualizaci√≥n S√≠ncrona de UI: Llama a updateAllBoards() para redibujar el contenido de la pizarra y nameTagManager.updateAllTags() para refrescar los prefijos de los nombres.

Gesti√≥n de Datos As√≠ncronos (Efectivo)
La lectura de datos de la base de datos es lenta y debe ser as√≠ncrona. Para que el efectivo (Cash) se muestre en el Scoreboard sin congelar el servidor, se utiliza un patr√≥n de cach√© y cooldown:

updateAllCashBalancesAsync: Este m√©todo solicita el saldo de efectivo de cada jugador de forma as√≠ncrona (cashManager.getCash(uuid).thenAccept(...)).

UPDATE_COOLDOWN (1 segundo): Un cooldown simple evita inundar el sistema de econom√≠a con peticiones en cada ciclo de actualizaci√≥n del Scoreboard, optimizando el uso de recursos.

cachedCash: El saldo de efectivo se almacena temporalmente en este mapa hasta la pr√≥xima lectura as√≠ncrona, permitiendo que el Scoreboard dibuje un valor reciente sin esperar la base de datos.

Construcci√≥n Robusta del Scoreboard
Para evitar problemas de parpadeo y asegurar que el Scoreboard se vea limpio, se utiliza una t√©cnica avanzada: usar Teams para ocultar la puntuaci√≥n.

setScoreboardLine(Objective, Scoreboard, String, int): Este m√©todo helper es el encargado de dibujar cada l√≠nea.

Puntuaci√≥n: La puntuaci√≥n (score) se usa √∫nicamente para forzar el orden de las l√≠neas.

Entrada √önica: Se genera una entrada de Scoreboard invisible y √∫nica por cada l√≠nea (getUniqueEntryByScore), usando c√≥digos de color para evitar que los n√∫meros de puntuaci√≥n se muestren.

Prefijo del Team: El contenido visible de la l√≠nea (el texto, ej. "‚ô• Vida: 100/100") se establece como el Prefijo del Team asociado a esa entrada, permitiendo una m√°xima flexibilidad de formato sin la limitaci√≥n de los 40 caracteres por entrada de Scoreboard.

Flujo de Datos y Coherencia
El ScoreboardManager garantiza la coherencia al depender de los Managers de datos existentes, siguiendo la Regla de la Fuente de Verdad de VendralyCore:

Datos RPG (Vida, Nivel): Se obtienen de StatManager y XPManager.

Datos de Rol: Se obtienen de AuthManager.

Los m√©todos de notificaci√≥n (notifyHealthChange, notifyLevelChange, etc.) act√∫an simplemente como un alias para llamar a updatePlayerBoard(), manteniendo la l√≥gica centralizada y f√°cil de mantener.

La clase tambi√©n maneja la creaci√≥n de Scoreboards nuevos para cada jugador (getOrCreatePlayerBoard) y la restauraci√≥n segura del Scoreboard principal al desconectarse (removePlayerBoard).

AuthUtil.java: Utilidades Criptogr√°ficas
=
La clase AuthUtil es una utilidad est√°tica que encapsula las operaciones fundamentales de seguridad de la autenticaci√≥n. Su prop√≥sito es garantizar que todas las contrase√±as de los usuarios sean procesadas criptogr√°ficamente antes de ser almacenadas, cumpliendo con las buenas pr√°cticas de la industria.

Hash de Contrase√±as (SHA-256)
El m√©todo hashPassword(String password) es la funci√≥n principal de esta clase.

Algoritmo: Utiliza el algoritmo de hash criptogr√°fico SHA-256 (Secure Hash Algorithm 256-bit). Este algoritmo es r√°pido, ampliamente aceptado y robusto, ideal para el hashing de contrase√±as.

Manejo de Bytes: Convierte la contrase√±a de texto plano en un array de bytes, lo hashea, y luego traduce el resultado en una cadena hexadecimal legible y segura, que es lo que se guarda en la base de datos (PlayerData).

Robustez: Incluye un bloque try-catch para manejar la improbabilidad de que el algoritmo SHA-256 no est√© disponible en el entorno Java, asegurando que la funci√≥n no falle silenciosamente.

Verificaci√≥n de Autenticaci√≥n
El m√©todo checkPassword(String password, String hashedPassword) es la funci√≥n que se ejecuta cada vez que un usuario intenta iniciar sesi√≥n o cambiar su contrase√±a.

Proceso: No compara la contrase√±a de texto plano con el hash almacenado. En su lugar, toma la contrase√±a enviada por el usuario, la hashea instant√°neamente usando hashPassword(), y luego compara el nuevo hash generado con el hash que ya est√° almacenado en la base de datos.

Seguridad: Si el hash generado coincide con el hash almacenado, se considera que la contrase√±a es correcta, sin que el servidor jam√°s vea o almacene la contrase√±a en texto legible.

Nota: Aunque el uso de SHA-256 es un buen est√°ndar, la implementaci√≥n es est√°tica y simple. No incluye salting (a√±adir datos aleatorios √∫nicos antes del hash), lo que es un paso de seguridad adicional. Sin embargo, para un sistema de autenticaci√≥n b√°sica de un plugin de Minecraft, esta implementaci√≥n es un comienzo seguro y funcional.

TradeGuiManager.java: Constructor de la Interfaz de Comercio Seguro
=`TradeGuiManager` es la utilidad responsable de construir el inventario de 54 slots utilizado en el comercio seguro. Se encarga √∫nicamente del dise√±o visual y de los botones de confirmaci√≥n.

Distribuci√≥n del inventario
El inventario se divide en tres zonas: la franja izquierda (slots 0-20) para el solicitante, la franja derecha (27-44) para el objetivo y un separador central de paneles grises (21-26) que evita interacciones cruzadas.

Controles inferiores
Los slots 45 y 53 contienen bloques de esmeralda llamados "Confirmar".
El resto de la fila inferior (46-52) se rellena con paneles grises para bloquear interacciones y mantener la simetr√≠a visual.

Relaci√≥n con TradeSession
La interfaz es compartida por ambos jugadores; `TradeSession` es quien controla qu√© slots son v√°lidos y cu√°ndo reiniciar el estado de confirmaci√≥n si cambia alguna oferta.

TradeManager.java: Coordinador del Comercio Seguro
=`TradeManager` coordina el ciclo de vida de los intercambios: solicitudes, creaci√≥n de la GUI y cierre de sesiones.

Flujo b√°sico
1. `/trade <jugador>` almacena una solicitud en `pendingRequests` y notifica al objetivo.
2. `/trade accept <jugador>` verifica la solicitud; si coincide, crea una `TradeSession` con la GUI compartida por `TradeGuiManager`.
3. `TradeListener` vigila la interfaz; cuando ambos jugadores confirman, `TradeManager` mueve los √≠tems y transfiere el dinero ofrecido utilizando `CashManager`.

Seguridad operativa
* Cada jugador s√≥lo puede tener una solicitud pendiente; una nueva sobrescribe la anterior.
* Al cerrar la interfaz se devuelven los √≠tems autom√°ticamente y se limpia la sesi√≥n.
* El manager expone `tick()` y `shutdown()` para permitir futuras expansiones (por ejemplo expiraciones autom√°ticas).

TradeSession.java: L√≥gica de la Transacci√≥n Segura
=`TradeSession` encapsula a los dos jugadores involucrados, su inventario compartido y el estado de confirmaci√≥n.

Elementos clave
* `getRequesterSlots()` y `getTargetSlots()` definen las posiciones v√°lidas para cada jugador.
* `setMoney(Player, double)` registra la oferta monetaria de cada lado y reinicia las confirmaciones.
* `toggleReady(Player)` alterna la marca de listo de quien presiona el bot√≥n.

Cuando ambos jugadores est√°n listos, `TradeManager` valida los fondos disponibles y realiza el intercambio de √≠tems y dinero. Si la sesi√≥n se cancela o se cierra la interfaz, `endSession` devuelve cada objeto a su propietario original y limpia el estado interno.


=
La clase Main.java es el punto de entrada (JavaPlugin) del proyecto VendralyCore. Su √∫nica responsabilidad es actuar como el orquestador central: establece la configuraci√≥n inicial, inicializa todas las clases manager en el orden correcto de dependencia y coordina el registro de todos los comandos, listeners y tareas programadas.

Esta clase es el hub que asegura la integridad de todos los sistemas al proporcionar acceso p√∫blico a cada manager mediante sus m√©todos getter.

Ciclo de Inicializaci√≥n (onEnable)
El m√©todo onEnable sigue un estricto orden de inicializaci√≥n por capas para garantizar que ning√∫n manager intente acceder a una dependencia que a√∫n no ha sido creada:

Persistencia y Configuraci√≥n: Inicializa primero el UserDataManager (el sistema I/O basado en YAML), creando la base para la carga y el guardado de datos.

N√∫cleo Base: Inicializa los gestores fundamentales: AuthManager (seguridad), EconomyManager, CashManager y TradeManager.

N√∫cleo RPG: Inicializa todos los subsistemas del motor RPG en orden:

StatManager (stats base y modificadores).

XPManager (curva de experiencia y puntos de atributo).

WorldDifficultyManager (niveles base y zonas de spawn).

ZoneSpawner (motor de spawn por zona).

AbilityManager (sistema de habilidades secundarias).

UI y Servicios: Inicializa PlayerListener y ScoreboardManager.

Registro y Tareas: Registra todos los comandos y listeners de todos los m√≥dulos. Finalmente, inicia las tres tareas principales de alto rendimiento:

StatManager.startRegenScheduler (Regeneraci√≥n de Estamina/Vida).

ZoneSpawner.startSpawnerTask (Spawn peri√≥dico de mobs).

ScoreboardManager.startUpdateTask (Actualizaci√≥n de la pizarra lateral).

Cierre de Seguridad (onDisable)
El m√©todo onDisable es fundamental para la integridad de los datos del servidor. El proceso de apagado es dise√±ado para un cierre limpio y seguro:

Detenci√≥n de Tareas: Detiene sistem√°ticamente todas las tareas recurrentes (Scoreboard, StatManager y ZoneSpawner) para evitar que sigan intentando ejecutarse mientras el servidor se apaga.

Persistencia:

Guarda la configuraci√≥n global del mundo (difficultyManager).

Ejecuta userDataManager.saveAll(), el paso m√°s cr√≠tico, que fuerza a todos los objetos PlayerData y RPGStats que est√°n en memoria a escribirse en sus respectivos archivos YAML.

Cleanup: Finaliza las sesiones de BossBar de los jugadores conectados, asegurando que no queden rastros de UI custom al apagar.

Este flujo garantiza que el plugin se inicie de forma ordenada, maneje sus recursos eficientemente en tiempo de ejecuci√≥n y garantice la persistencia total de los datos al cerrarse.

PlayerJoinListener.java: Sincronizaci√≥n de Salud NMS
=
Esta clase Listener es un componente cr√≠tico de la capa de interfaz de usuario de salud RPG. Su √∫nica responsabilidad es asegurar que la salud nativa de Minecraft se sincronice con el sistema de salud custom de VendralyCore y que la barra de salud vanilla no sea visible, evitando que se muestren dos barras de salud a la vez.

Flujo en la Conexi√≥n (onPlayerJoin)
El evento de conexi√≥n es el momento m√°s importante para esta clase:

Obtenci√≥n de Datos: Obtiene la Vida M√°xima RPG (rpgMaxHealth) del jugador a trav√©s del StatManager (la fuente de verdad).

Sincronizaci√≥n Bukkit: Sincroniza el atributo Attribute.MAX_HEALTH de Bukkit con el valor de salud RPG obtenido. Esto es esencial para que la vida nativa del jugador (el valor subyacente que reporta el juego) sea el correcto.

Ocultar Vanilla: Utiliza el m√©todo est√°tico NMSHealthUtil.hideVanillaHealth(player, rpgMaxHealth) para manipular la representaci√≥n visual del HUD del jugador. Esto es lo que oculta los corazones nativos, dejando espacio para que tu BossBar custom de salud se dibuje sin conflictos visuales.

Flujo en el Respawn (onPlayerRespawn)
El evento de respawn se utiliza como una medida de redundancia:

Aunque Bukkit ya restablece el atributo de MAX_HEALTH al morir, el respawn puede, en algunas versiones, reiniciar o mostrar brevemente la barra vanilla.

El listener vuelve a invocar a NMSHealthUtil.hideVanillaHealth inmediatamente despu√©s de que el jugador reaparece, asegurando que la barra vanilla se mantenga oculta y que el jugador vea inmediatamente su salud custom.

En resumen, esta clase act√∫a como el puente de compatibilidad entre la API de Bukkit/NMS y el motor de salud RPG de tu servidor.

NMSHealthUtil.java: Ocultamiento de Salud Vanilla
=
La clase NMSHealthUtil es una utilidad est√°tica de bajo nivel cuyo √∫nico prop√≥sito es manipular la barra de salud (corazones) nativa de Minecraft. Esto es esencial para el motor RPG de VendralyCore, ya que permite ocultar los corazones vanilla y utilizar completamente el HUD custom (generalmente una BossBar o un Canvas de salud) sin duplicidades visuales.

Mecanismo Central: El "Truco NMS"
El ocultamiento se logra mediante una t√©cnica conocida que explota c√≥mo el cliente de Minecraft procesa los valores del atributo GENERIC_MAX_HEALTH:

Valor de Quiebre (HIDE_VALUE): Se utiliza un valor no est√°ndar, como 1024.0, para establecer el MAX_HEALTH de forma temporal. Este valor no tiene sentido en el contexto vanilla (el m√°ximo normal es 1024.0, pero el juego asume 20 o 40 por defecto) y fuerza al cliente a dejar de dibujar los corazones en el HUD.

Velocidad: El truco requiere una ejecuci√≥n extremadamente r√°pida: el valor de quiebre debe ser establecido y restaurado inmediatamente para evitar cualquier cambio real o visible en el estado del juego.

Pasos Cr√≠ticos para el Ocultamiento Seguro
El m√©todo hideVanillaHealth(Player, double) ejecuta esta secuencia cr√≠tica, asegurando que la vida real del jugador no se vea afectada:

Configuraci√≥n del Atributo: El MAX_HEALTH se establece temporalmente en el valor de quiebre (HIDE_VALUE = 1024.0).

Forzar Paquete: Para que el cliente procese el cambio de MAX_HEALTH, se debe forzar una actualizaci√≥n del valor de vida actual (player.setHealth()). Si el jugador tiene vida completa, su vida se baja m√≠nimamente (- 0.0001) y se restaura al valor original.

Restauraci√≥n Inmediata: Inmediatamente despu√©s de forzar el paquete, el valor MAX_HEALTH es restaurado a su valor real de RPG (por ejemplo, 1000.0) y la vida actual vuelve a su valor original (actualHealth).

Este proceso sucede en el mismo tick del servidor, haciendo que sea invisible e imperceptible para el jugador, pero garantizando que la barra de corazones nativa desaparezca de su HUD.

Manejo de Casos Extremos
La utilidad tambi√©n verifica si el rpgMaxHealth es bajo (menor o igual a 20.0). En este caso, el truco se omite, y el atributo de salud se establece a 20.0. Esto permite que la barra de salud vanilla se muestre correctamente para jugadores que el sistema RPG considera en modo Vanilla o si tu sistema de salud custom est√° deshabilitado temporalmente.

