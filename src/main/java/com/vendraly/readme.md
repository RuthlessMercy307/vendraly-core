Cosas a implementar
=
Trabajos:
Herrero: Sus armas y herramientas crafteadas tienen una probabilidad (basada en el nivel) de recibir un encantamiento aleatorio de bajo nivel (ej: Unbreaking I o Sharpness I) o más durabilidad. pequeña probabilidad de sus herramientas o armas salir con 1 punto de vida

Boticario: Sus pociones creadas tienen una probabilidad (basada en el nivel) de recibir una duración mayor (en segundos) o un nivel de efecto superior (ej: Strength II en lugar de Strength I). pequeña probabilidad de sus pociones explotar

Sastre: Sus armaduras tienen una probabilidad (basada en el nivel) de recibir un encantamiento aleatorio de bajo nivel,  pequeña probabilidad de sus armaduras salir con 1 punto de vida

Leñador: Gana un aumento de daño y velocidad con hacha Generación de Mobs Hostiles: Al talar madera, tiene una probabilidad creciente (basada en el nivel) de que aparezca un mob específico ejemplo un oso)

Minero: Gana un aumento de velocidad de minado con pico. La mina tiene un loot especial (dinero de mina o ítems de mejora de herramientas) solo obtenible con el trabajo activo. PvP Obligatorio/Riesgo de Pérdida: Los recursos valiosos están en zonas PvP de la mina. Si muere, pierde sus "mejoras de herramientas" temporales (ítems en su inventario) a manos de su asesino.

Pescador: Puede craftear y usar cañas de pescar temáticas (caña de libros, caña de comida) que aumentan la probabilidad de un loot específico. Aparición de Mob hostil: Una probabilidad de que al pescar, en lugar de un pez, un mob hostil fuerte (ej: Guardián Elder con nombre personalizado) aparezca cerca y lo ataque.

Repartidor: Dinero garantizado por entrega exitosa. Si no se le paga al día (porque no hizo entregas), pierde un pequeño porcentaje de su dinero total (mantenimiento de Elytra). Pérdida por Tiempo/Costo: Si no llega a tiempo, el jugador pierde el dinero que gastó en cohetes para el viaje

Cocinero: Dinero garantizado y capacidad de crear alimentos de alta calidad (con efectos de poción casi que como las manzanas xD) para el resto de los jugadores.  crear alimentos de alta calidad (con efectos de poción permanentes o más intensos) para el resto de los jugadores.Pérdida de Ingredientes: Si el tiempo límite expira o usa los ingredientes incorrectos

Garçom (Mesero): Es uno de los trabajos más fáciles de ganar dinero rápido. Pérdida por Movimiento: Si se mueve demasiado rápido (saltos, sprinting constante) mientras sostiene el "plato" (un ítem personalizado), el plugin puede detectar el movimiento y destruir el ítem, forzándolo a empezar de nuevo.

Ladrón: Capacidad de robar ítems aleatorios de otros jugadores (usando la API de Inventario). Beneficio Extra: Al usar la habilidad, temporalmente obtiene la skin de algun mob del juego y se le oculta el nombre por cierto tiempo, Riesgo/Sistema de Detención: Si es detectado por un Guardia (el Guardia lo derriba al casi matarlo), pierde todo el dinero e items que tenia encima y es enviado a la cárcel.

Guardia: Gana una bonificación de dinero significativa por cada Ladrón que detiene/encarcela. abran npc ladrones tambien y un tiempo limite para perseguir el ladron. Costo de Servicio: Si el Guardián no detecta y detiene a un Ladrón por un periodo de tiempo, pierde una pequeña cantidad de dinero por "negligencia" (mantener el sistema de ley es costoso).

Cazador: Recompensa en Dinero y Loot por cráneos/cabezas de mobs o jugadores fugitivos (PvP). Aumento de Hostilidad de Mobs: En las zonas de caza, los mobs le causan más daño que a un jugador normal, por ser un depredador conocido.

Clanes:
Los jugadores podran crear un clan al comprar el nexus del clan (un standarte especial) con limite de 5 mienbros,

Para expandir la cantidad de mienbros en el clan deben raidear a otros y  destruir el nexus para conseguirlo, y de esta forma al fucionar los dos nexus se consiguen uno de mayor nivel

Al un clan destruir otro la prote del clan destruido desaparece

Las protecciones de los jugadores que pertenecen al clan cuentan como cosas del clan, no como cosas de los jugadores individuales (pa que si se meten al clan ps son una familia, si quieren sus cosas individuales ps que juegueen solos)

El clan podra comprar cositas que son como granjas (que seran caras la verdad) parecidas a las de bedwars, que sueltan algun item como hierro, oro, diamantes, etc pasivamente, y las pueden mejorar para que suelte mas cosas pero siempre sera caro, ademas debe comprarse con el dinero del clan (que se deposita en el nexus, asi si los raidean tambien les pueden quitar el botin del clan xd)

Un clan no puede ser atacar ni ser atacado por otro clan si solo tiene 1 mienbro del clan conectado, necesita minimo 2 conectados para poder habilitar la opcion (Lo cual me parece poco pero no creo que superemos las 5 personas dentro del  serverxd)

si un jugador abandona un clan, debe esperar 3 dias (de la vida real) para poder entrar a otro
si el jugador abandona el clan no se lleva las protecciones ni recupera el dinero que puso en el nexus

Crafteo de armas y armaduras:
Los jugadores deberan subir sus habilidades pasivas (se mejoran al ser usadas) de crafting
al tener niveles bajos tendran poca vida/resistencia todas las cosas que craftee ademas de titulos bajos, y niveles mas altos dan titulos mejores
Titulos:
-comun
-raro
-epico
-legendario
-mitico


las armas no suman daño, sino que te dejan usar el daño que tienes, igual con la velocidad, ejemplo, golpe con mano daño maximo 5, espada de madera daño maximo 10, espada de piedra daño maximo 15, espada de hierro daño maximo 30, espada de diamante daño maximo 50, espada de netherite daño maximo sin limite

la velocidad de ataque tambien va cambiando, pero tiene un minimo tambien, ejemplo, no puedes usar netherite si no tienes tu nivel de ataque por lo menos 51, la de diamante minimo 31 y asi, para cosas como picos o hachas tienen su daño y velocidad tambien, ya que la velocidad la mejoramos como habilidades

las herramientas que tenga un material mejor te permite usar mas de tu velocidad/daño etc, mientras que tu nivel de habilidad de crafteo las comunes raras y esas asi, la calidad cambia solo la durabilidad, puede haber una espada de madera legendaria, o una de netherite comun y asi, tambie para cada una dependiendo el material para crear una de buena calidad no solo necesitas el material y el mismo nivel que una de madera, necesitas nivel de crafteo mas alto

las armas y armaduras tienen atributos dependiendo de su calidad
-comun 1 atributos
-raro 2 atributos
-epico 3 atributos
-legendario 4 atributos
-mitico 5 atributos

ademas de niveles que los niveles dan mas estadisticas a esos atributos
los niveles de los atributos van de acuerdo con el nivel de la habilidad, ejemplo:
un sastrero de nivel 50 puede hacer que un arma salga nivel 50 o menos

Saqueo de cofres con descubrimiento:
Al igual que otros juegos como por ejemplo KCD1 o Arena Breackout
al "robar/abrir" debes descrubrir item por item dandole click, para poder ver que es y luego tomarlo, haciendo que no solo sea abrir y agarrar todo, pero los cofres que ya conoces no tendran ese estilo de carga
se le aplica el mismo tipo de descubrir cuando inspeccionas/robas del inventario de otro jugador directamente

la habilidad agilidad va a hacer que el descubrimiento sea mas rapido o lento

Hechizos y funciones con voz (ya fue agregado como plugin aparte)
el mod de voz al detectar que dice la gente, y dependiendo la palabra si cumplen X requisitos puedan usar Hechizos

se introduciran algunas armas unicas que aun no se deciden cuales seran, cuando se dice unica es que no hay otra igual a esa, ya que tendra una habilidad perzonalisada

Tendran que matar algunos boss para poder conseguir jefes que aun no se decide cuales seran
-enderman: item que teletransporta si te pegan (probabilidades)
-Thor?
-Gigante de fuego
-Rey esqueleto
-dragon (ya viene pero ahora más op)
-serpiente del mar que olvide su nombre 
y no se que otros jefes poner pero por ahora solo esos

Para descubrir algunas cosas deben seguir el lore, ya que le dara informacion para descubrir los puzles y desbloquear nuevas zonas  o conseguir algun item especial


-No forma de conseguir reparacion ya que sera eliminada con un plugin, las unicas cosas con reparacion seran las armas o armaduras unicas

Sistema de robo y inspección publico
similar a lo de los cofres pero es con un comando
al hacer el comando ejemplo /robar ruthless se intentara robar al usuario ruthless si esta por lo menos a 5 bloques de distancia (que ya me parece mucho, tal vez sea mejor 3) pero como funciona? ps tienes que descubrir item por item como con los cofres que viene ofuscado pero ahora aplicado al inventario del jugador que intentas robar
mientras que con inspeccion es diferente, aunque tambien te permita ver el inventario del jugador enemigo con ofuscamiento y debas descubrir uno a uno, en modo inspeccion no podras tomar nada del inventario, ademas que el tiene la opcion de ocultar algunos 
para el usuario que esta siendo inspeccionado porder ocultar algun item, esto es un ocultamiento temporal, debe darle click a ese item, de esta forma el item comenzara un conteo regresivo (coldown como cuando atacas con un arma o tocas una trompeta y aunque esta en inventario se le ve el coldown) al ese coldown acabar el objeto se muestra pero el jugador inspeccionado puede volverle a dar click antes del coldown acabar para poder rellenarlo de nuevo y asi ocultarlo mas tiempo, ejemplo de rellenado, si el primer daba 3 segundos de ocultamiento, cuando quedaba 1 segundo para ser mostrado al darle click vuelve a estar con los 3 segundos de coldown

Ataque y defensa kcd1:
Estaba pensando mucho como hacerlo, será más que como kdcd1 mas un tipo mount and blade

-Las direcciones se ven arriba del player con una flecha fantasma que te muestra la direccion, hay 5 direcciones (como en kingdom come deliverace 1 pero sin el del medio)
-si un jugador se defiende con la espada (solo tiene espada a mano y mas nada) obtiene inmunidad de esa dirección por x tiempo (tal vez 1 segundo ya que los ataques normalmente lo hacen a 1.8 para el máximo daño)
-el ataque dependera tambien la direccion, y tendra un pequeño coldown antes de hacerce efectivo de 0.3segundos (ese tiempo para test) asi el jugador enemigo tiene tiempo de reaccionar
-Defensa solo disponible con espadas
-defensa perfecta vs inperfecta: al hacer una defensa perfecta (durante del coldown antes del ataque hacerce efectivo, se mostrara un icono pequeño en pantalla para saber si esta en el momento perfecto o no) no importa a que direccion defendio, al ser una perfecta el ataque del enemigo no vale nada, hace 0 daño, y el enemigo pierde bastante estamina, mientras que con una defensa imperfecta, osea que se defendio en la direccion correcta pero no durante el momento perfecto, esto hara que el jugador que defendio pierda estamina pero no recibe el daño
-combos: tambien se podran hacer combos especificos, para que de esta forma al alguien hacerlo con exito (ejempo: arriba, derecha, derecha abajo) el tercer golpe en el caso de ese combo de ejemplo no le afectaria la defensa, no importa si es defensa perfecta o inperfecta, hara el 100% del daño y hara al enemigo perder estamina, pero el combo es valido solo si todos los golpes fueron defendido con defensa inperfecta, y en cierto tiempo para evitar que hoy me defiendes y mañana te termino el combo


seguridad en cofres:
ya que los cofres no estan bloqueados por protecciones (salvo no tengan por lo menos 1 del clan o el dueño del cofre online) existiran los cofres con llave tambien
Cierto tipo de cofres tienen candado (deben comprarlo) tendrá una llave para poder abrirlo
Si compran ganzua entran en minijuego para abrir el cofre
Bloque de detector de intruso: detecta si alguien paso por encima de el, te da el nombre la hora y el día
Puerta con llave: puerta que se abre solo con la llave en la mano o ganzua
Puerta con detector: puerta que detecta quien intenta abrirla, si es el dueño o alguien con permiso lo deja, sino se queda ahí nomás cerrada
Tal vez piensen que eso ya pasa con plugins de protección, pero en mi caso el plugin lo hago yo, y aunque estés en protección si tú cofre o tu puerta no es de estas cualquiera puede entrar, sla protección es solo para que no rompan nada ni hagan spawn mobs dentro de tu zona (y no se si poner algo extra)
Así con eso de las puertas y las llaves ni los de tu clan tendrá permiso por un lado
-las ganzuas tienen limite de uso antes de romperse, pero solo se rompen si fallan el minijuego al intentar abrir cofres o algo

Party:
los jugadores podran tener party dependiendo su honor, mientras mas honor mas personas en su party, las personas de la party no pueden estar demasiado lejos, deben estar almenos a 500 bloques de distancia (o tal vez menos pq 500 parece mucho), mientras tanto, todos los que esten dentro de la party recibiran recomensas iguales, pero 50% menos a la original independiente de la cantidad de personas, de esta forma, si hay 3 persnas en la party es mas conveniente, ya que asi digamos que a 1 jugador le deberia dar 10 de dinero y 10 de exp por matar un slime lvl 5, ahora como anda en party de 2 le daria 5 de dinero y exp a cada jugador, si hay 3 jugadores en la party entonces le da 5 de dinero y exp a cada jugador, si hay 4 en la party le da 5 de dinero y exp a cada igualmente

--Mobs sueltan dinero (olvide ponerlo)

derribado:
los jugadores no mueren instantaneamente, sino que quedan derribados en el suelo al tener 1 corazon de vida y obtienen inmortalidad hasta que se acabe el tiempo y se terminen de morir, para alguien revivirlo debe estar almenos a 2 bloques de distancia de el y estar agachado (shift) para revivirlo

Secuestros:
si un jugador esta derribado, tienen la opcion de revivirlo o secuestrarlo, al usar /secuestrar [nombre] y estar a almenos 3 bloques de distancia, el jugador se vuelve pequeño y quedara en tu espalda, ademas de que se le restaurara 3 puntos de vida, leugo con el /soltar [nombre] soltaras al jugador, pero estara con hambre y 2 corazones de vida

grilletes: 
para encarcelar jugadores o al secuestrarlos, deberas usar grilletes, que hacen que el jugador al que se los pusistes (le diste click derecho al jugador mientras tenias el item en la mano) el jugador quedara congelado, y se volvera inmortal mientras tenga grilletes, osea, siempre tendra 2 corazones de vida y 1 punto de comida, para liberarlo debes usar las llaves que conseguiste con el grillete para que asi se pueda ir

Portal al cielo:
para ir a un templo en el cielo se puede ir con un portal, creando un 4x5 de piedra luminosa y un bloque de agua en el centro, de esta forma se creara el portal al cielo (que nada mas te da tp a un lugar que estara marcado como cielo con el comando /cielo)

dragon:
podras volar en dragones, usaremos a algun mob como el happy ghast pero con las texturas del dragon del end, para que jugadores puedan volarlo (pero eso es cierta recompensa)

comando para -Murcielago mensajero
lo que hace es que al poner el /murcielagomensajero [jugador destino] mensaje. el murcielago le llevara a ese jugador un libro que contiene el mensaje para que lo lea,para el jugador saber cual era el murcieralo, el murcielago lo atacara pero no le hara daño, y el libro lo dropea


-Las proteccion es para que no destruyan los otros jugadores, ni quemen, pero los mobs si pueden rompertela

-Los cofres protegen si estás offline, si estás online se desprotegen (pa que roben en tu caraxd)

-Proteccion solo protege de jugadores y mobs

las protecciones no se hacen con un bloque, se compran con un comando, con tamaño perzonalisado, el que prefieran, solo que deben pagar un precio por cada espacio protegido, ejemplo si es un 5x5x5 deben pagar por los 125 bloques que esten protegiendo asi sea de aire

las protecciones les deben poner nombre para identificarlas, asi saber si quieren eliminar alguna o algo

las protecciones pagan impuestos por las tierras, si el jugador compra una proteccion demasiado grande 1000x100x1000 los impuestos seguiran cobrandose y si el jugador no tiene dinero para pagar esos impuestos, entonces la proteccion desaparecera

si un jugador entra a un clan sus protecciones dejan de ser de el y pasan a ser del clan, los impuestos los paga el clan, si el jugador abandona el clan no se lleva las protecciones ni recupera el dinero que puso en el nexus

que los monstruos también tengan lvl, cada x tiempo el nivel de los nuevos monstruos va subiendo, y se pueda configurar también oleadas a las bases de jugadores (dónde están las piedras con protección) (esto ya lo hicimos pero tiene algunos bugs)

los portales están bloqueados, osea la gente no puede andar por ahí cruzandolos, además de construirlos deben comprar un pase, el pase tiene 1 uso y se consume al cruzas el portal, de esa forma deben conseguir "dinero" y gastarlo en cosas útiles así, y no viajarán cada tres segundos sino que viajarán intentando conseguir la mayor cantidad de cosas sin andar ida y vuelta a cada rato (a menos que farmeen dinero)

compran y venden objetos a npc, y hacen trade entre jugadores por dinero, cumplen misiones diarias para conseguir dinero

al matar monstruos consigues exp de siempre, y dependiendo tu nivel puede ponerte mas fuerza, más vida, más velocidad de picar, de talar, o cosas asi, que sea ilimitado ya que será difícil ganar exp


los jugadores ganan dinero también participando en directos de los streamers del server, o conversando o haciendo llamadas en el server de discord, así aunque no estén en el juego pueden ganar dinero y apoyamos al sv de dc y a los streamers en twitch

esquivar: al darle shift los jugadores esquivan ataques, lo que los hace invulnerabels por x tiempo con coldown de x tiempo (ya fue implementado)

cosas para agregar que aun no detallo
=
Mazmorras generadas proceduralmente
Reliquias antiguas (ítems únicos en el servidor que tienen historia y cambian de dueño).
Cofres mimics: cofres que se transforman en mobs cuando intentas abrirlos.
Mecánica de reliquias malditas: ciertos ítems atraen mobs si los llevas en el inventario.
Sistema de reputación/fama:
NPC bardos: los jugadores pueden pagarles para contar historias o rumores.
Carreras de caballos con apuestas.
Arena de gladiadores con ranking mundial (ELO PvP).
Minijuego de dados/cartas en tabernas para ganar ítems raros.
Sistema de música: instrumentos que reproducen melodías y sirven como buffos (bardos).
Territorios reclamables: jugadores o gremios pueden conquistar regiones y cobrar impuestos.
Sistema de bandidos NPC que atacan caravanas de aldeanos y secuestran jugadores para pedir dinero para el rescate
Economía dinámica: precios suben o bajan según escasez de recursos en el servidor.
IA tipo “dungeon master” (plugin que genera misiones según la actividad de los jugadores). ?Xd
Economía realista: inflación, impuestos, bancos con préstamos.
Caza de recompensas PvP: los criminales con más robos aparecen en tablón de se busca.
Reclamar aldeas / impuestos

Puedes hacer que cada aldea sea un “territorio fiscal”.

El jugador/gremio que la controla recibe una renta periódica (dinero por cada aldeano).

Los aldeanos siguen trabajando normal, pero cada cierto tiempo pagan impuestos que va al dueño.

Se puede permitir “revuelta” de aldeanos si el impuesto es muy alto o si el dueño tiene mala reputación → los aldeanos pueden dejar de trabajar, huir, o hasta pedir ayuda a otros jugadores.

Los dueños pueden “mejorar” la aldea: guardias, murallas, talleres. Eso multiplica la renta.

Lo de los “esclavos” estilo huevos de aldeano queda como un ítem raro de mercado negro → un aldeano encapsulado que puedes liberar donde quieras. Puede dar rol tanto para los de mala fama (tráfico de aldeanos) como para los de buena fama (fundar aldeas nuevas).
Los seguidores npc si lo puedo hacer? Xd pq osea, tendría que hacer que persigan al dueño y puedan pelear como si fueran jugadores de verdad, que ataquen a cualquiera que les haga daño, a cualquiera que haga daño a los de su "party" y a cualquiera que el dueño le pegue (algo así como los perros ahora que pienso pero en versión jugadores npcxd)

⚪ Buena fama:
Contratos exclusivos: NPCs nobles solo dan misiones a héroes reconocidos.
Seguidores NPC: puedes contratar escuderos, aprendices o mercenarios baratos.
Poder político: si tu fama es muy alta, puedes ser automáticamente propuesto como líder de una aldea o ciudad.
Acceso a áreas sagradas: templos, bibliotecas secretas, reliquias mágicas que NPCs no mostrarán a “bandidos”.
Los bandidos intentan secuestrarte cada x tiempo

⚫ Mala fama
Mercado negro: acceso a objetos ilegales (armas malditas, pociones prohibidas).
Aliados criminales: NPCs bandidos no te atacan, incluso te dan misiones.
Infamia como poder: tu nombre aparece en tablones de “Se busca”, otros jugadores o NPCs te cazan → pero si sobrevives ganas bonus

Documentación de Componentes Clave
=
(VendralyCore)
El Flujo de Datos Crítico: PlayerData, UUID y AuthManager
   Este es el concepto más importante para prevenir bugs de sincronización y garantizar la seguridad de los datos:

Reglas Inmutables del Estado del Jugador:
Origen (Conexión): El evento de conexión (PlayerJoinEvent) proporciona el UUID y el Name del jugador.

Carga (Persistencia): El AuthManager utiliza el UserDataManager para leer el archivo [UUID].yml y crear un único objeto PlayerData en la memoria (caché).

Fuente de Verdad (Caché): Mientras el jugador está conectado, el objeto PlayerData almacenado en el AuthManager es la ÚNICA fuente de verdad para sus datos (balances, roles, estadísticas).

Uso Correcto: NUNCA se debe leer o escribir directamente al UserDataManager o a la API de Bukkit para obtener datos de un jugador online. Siempre se debe obtener el objeto PlayerData del AuthManager.

Markdown

// Ejemplo de Uso CORRECTO para jugadores ONLINE:
PlayerData data = plugin.getAuthManager().getPlayerData(player.getUniqueId());

// Modificar datos directamente en el objeto en memoria
data.setBalance(data.getBalance() + 50.0);

UserDataManager.java
=
   El UserDataManager es la capa de entrada/salida (I/O) del plugin. Su único trabajo es mover datos entre el disco (archivos YAML) y la memoria (PlayerData). No gestiona el estado en memoria, solo la persistencia.

Funciones Principales de Persistencia
getPlayerConfig(UUID uuid):

Propósito: Obtiene o crea el objeto YamlConfiguration (el archivo YAML) para un jugador.

Nota: Utiliza un caché ligero para evitar re-leer el disco repetidamente.

savePlayerConfig(UUID uuid):

Propósito: Guarda el objeto YamlConfiguration que está en caché en el disco (.yml).

Nota: Debe llamarse solo si se modificó el YamlConfiguration directamente.

loadPlayerData(UUID uuid, String username):

Propósito: Método Canónico de Carga. Lee todos los datos (Auth, Economy, RPG) del archivo YAML y crea una nueva instancia de PlayerData.

Nota: Usado por el AuthManager solo al conectar un jugador.

savePlayerData(PlayerData data):

Propósito: Método Canónico de Guardado. Toma el objeto PlayerData de la memoria (del AuthManager), lo serializa y lo guarda al archivo YAML.

Nota: Es la función principal de guardado. Se llama al desconectar y después de cambios críticos.

unloadPlayer(UUID uuid):

Propósito: Limpia la caché de configuración (YamlConfiguration) del jugador en el UserDataManager.

Nota: Se llama al desconectarse (después de que se hayan guardado los datos).

saveAll():

Propósito: Fuerza el guardado de todas las configuraciones YAML pendientes en el caché.

Nota: CRÍTICO. Se llama justo antes de que el plugin se apague (onDisable).

Funciones de Utilidad (Offline/Chequeo)
setPlayerRole(UUID uuid, Role role):

Propósito: Utilidad Offline. Cambia directamente el rol de un jugador en el archivo YAML y actualiza su historial.

Nota: Usado principalmente para comandos administrativos en jugadores offline.

getUUIDFromUsername(String username):

Propósito: Búsqueda Asíncrona. Intenta obtener el UUID de un jugador a partir de su nombre (buscando online y luego en los archivos YAML).

Nota: LENTO. Necesario para comandos de moderación como /vban <nombre> si el jugador está offline.

isRegistered(UUID uuid):

Propósito: Comprueba el estado de registro directamente en el archivo YAML.

Nota: Se utiliza para verificar el estado de registro de jugadores offline.

playerFileExists(UUID uuid):

Propósito: Verifica si el archivo de datos ([UUID].yml) existe en el disco.

getPlayerName(UUID uuid):

Propósito: Obtiene el último nombre conocido de un jugador desde el archivo YAML.

CashManager.java
=
El CashManager se encarga de gestionar todas las operaciones de la economía de efectivo robable (cash_balance). Su principal objetivo es asegurar que todas las operaciones de I/O sean asíncronas y que la arquitectura de caché (AuthManager) se respete rigurosamente.

Regla Fundamental: Flujo Bifurcado
El CashManager utiliza dos caminos lógicos para garantizar la seguridad de los datos:

Jugador ONLINE: Accede al PlayerData directamente desde el caché del AuthManager (lectura y modificación instantánea). No toca el disco.

Jugador OFFLINE: Carga el PlayerData del disco a través del UserDataManager (lento, asíncrono), aplica el cambio, y guarda al disco.

Funciones Asíncronas Principales
getBalance(UUID uuid):

Propósito: Obtiene el saldo de efectivo de forma asíncrona.

Nota: Si está ONLINE, lee del caché (rápido). Si está OFFLINE, lee del disco (lento).

modifyBalance(UUID uuid, double amount):

Propósito: Añade o resta una cantidad al saldo de efectivo de forma asíncrona.

Nota: Mantiene la integridad: Si está OFFLINE, guarda los cambios al disco inmediatamente. Si está ONLINE, modifica el objeto en memoria para que el AuthManager lo guarde al desconectar.

transferCash(UUID sender, UUID recipient, double amount):

Propósito: Transfiere una cantidad entre dos jugadores de forma asíncrona.

Nota: Utiliza una cadena de promesas (thenCompose) para garantizar que la resta y la suma ocurran secuencialmente (Transacción "casi-atómica").

getCash(UUID uuid):

Propósito: Alias de conveniencia para getBalance(uuid).

modifyCash(UUID uuid, double amount):

Propósito: Alias de conveniencia para modifyBalance(uuid, amount).

🛑 Advertencia: Métodos Sincrónicos (.join())
Los siguientes métodos son provistos para conveniencia en la API de Bukkit, pero bloquean el hilo principal (el juego) hasta que la operación asíncrona termina. Su uso debe minimizarse solo a comandos y eventos que puedan tolerar un pequeño retraso.

getBalance(Player player): Obtiene el saldo síncronamente.

take(Player player, double amount): Resta efectivo síncronamente (ej. al comprar).

give(Player player, double amount): Da efectivo síncronamente.

EconomyManager.java
=
El EconomyManager gestiona el saldo bancario (balance) de los jugadores. Al igual que el CashManager, utiliza un flujo de datos bifurcado para respetar la arquitectura central (AuthManager) y asegurar que todas las operaciones de disco sean asíncronas.

Arquitectura de Acceso Seguro
Jugador ONLINE: Los accesos de lectura y modificación se dirigen al objeto PlayerData en el caché del AuthManager (acceso instantáneo).

Jugador OFFLINE: La carga y el guardado se dirigen al disco a través del UserDataManager (proceso asíncrono).

Funciones Asíncronas Principales
getBalance(UUID uuid):

Propósito: Obtiene el saldo bancario de forma asíncrona.

Nota: Si está ONLINE, lee del caché. Si está OFFLINE, lee del disco de forma segura.

modifyBalance(UUID uuid, double amount):

Propósito: Añade o resta una cantidad al saldo bancario de forma asíncrona, con validación de saldo negativo.

Nota: Si el jugador está OFFLINE, guarda los datos al disco. Si está ONLINE, modifica el objeto en memoria y el AuthManager se encarga del guardado posterior.

transferBalance(UUID sender, UUID recipient, double amount):

Propósito: Transfiere una cantidad entre dos jugadores de forma asíncrona.

Nota: Implementa una lógica secuencial (thenCompose) para verificar el saldo del remitente antes de ejecutar la transferencia, garantizando la integridad de la transacción.

DamageLimitListener.java
=
El DamageLimitListener implementa el sistema de Límite de Daño por Arma, crucial para el balance del sistema RPG. Asegura que los jugadores con niveles altos de Fuerza no puedan usar armas de baja calidad para infligir daño excesivo.

Arquitectura y Dependencias
Este Listener depende del StatManager para obtener las estadísticas RPGStats del jugador y asume que el StatManager ya ha aplicado el bono de daño al evento antes de que este Listener se ejecute.

Utiliza la librería Adventure para la notificación de la barra de acción (sendActionBar).

Funciones Principales
extractDamageLimit(ItemStack item):

Propósito: Analiza el Lore del arma (ItemStack) para encontrar una línea específica (p. ej., "Límite de Daño: 50").

Resultado: Devuelve el valor del límite, expresado en Puntos RPG de Fuerza. Si no encuentra un límite o si la línea es "SIN LÍMITE", devuelve un valor alto por defecto.

onPlayerAttack(EntityDamageByEntityEvent event):

Propósito: Intercepta el evento de daño cuerpo a cuerpo de un jugador.

Lógica de Límite (CRÍTICA):

Compara los Puntos de Fuerza del jugador con el límite de Puntos de Fuerza permitido por el arma.

Si los Puntos del jugador son mayores que el límite, el daño debe ser limitado.

Calcula el Daño Base de Bukkit (Daño de arma + vanilla) restando el bono RPG total aplicado por el StatManager.

Calcula el Bono RPG Máximo Permitido usando el límite del arma.

Establece el daño final del evento como la suma del Daño Base de Bukkit y el Bono RPG Máximo Permitido.

Notificación: Envía un mensaje de acción al jugador indicando que su daño fue limitado.

ItemRequirementListener.java
=
El ItemRequirementListener implementa el sistema de Restricción de Ítems basado en las estadísticas RPG del jugador. Su propósito es impedir que los jugadores usen armas o herramientas de alto nivel si no han invertido suficientes puntos en el atributo requerido.

Arquitectura y Dependencias
Este Listener depende completamente del StatManager para obtener el objeto RPGStats del jugador y leer sus niveles de atributos (e.g., Fuerza, Velocidad).

Funciones Principales
extractRequirement(ItemStack item, String requirementType):

Propósito: Analiza el Lore de un ítem en busca de una línea específica que contenga el requisito mínimo (p. ej., "Requisito Mínimo de Fuerza: 50").

Resultado: Devuelve el valor numérico del requisito (50 en el ejemplo), o 0 si no se encuentra.

onEntityDamage(EntityDamageByEntityEvent event):

Propósito: Bloquea los ataques si el jugador no cumple con los requisitos del arma.

Bloqueo de Fuerza: Verifica si el nivel de Fuerza del jugador cumple con el requisito "Fuerza" del arma. Si falla, cancela el evento (event.setCancelled(true)) y notifica al jugador.

Verificación de Velocidad: Verifica un requisito "Velocidad" (si existe), pero solo notifica al jugador que el arma se siente pesada; no cancela el daño.

onBlockBreak(BlockBreakEvent event):

Propósito: Bloquea la recolección de bloques si el jugador no cumple con los requisitos de la herramienta.

Bloqueo de Recolección: Verifica si el nivel de Fuerza del jugador (o el stat de recolección si se implementa) cumple con el requisito "Fuerza" de la herramienta. Si falla, cancela el evento y notifica al jugador.

LootRestrictionListener.java
=
El LootRestrictionListener es un componente de balance de juego cuyo objetivo principal es bloquear la obtención del encantamiento Reparación (Mending) de fuentes que podrían desequilibrar la progresión del servidor.

Funciones Principales
isMendingBook(ItemStack item):

Propósito: Función de utilidad crucial para verificar si un ItemStack es un Libro Encantado que contiene el encantamiento Enchantment.MENDING.

Mecanismo: Utiliza EnchantmentStorageMeta para inspeccionar los encantamientos almacenados dentro del libro.

onPlayerFish(PlayerFishEvent event):

Propósito: Bloquea la obtención de Mending a través de la Pesca (una fuente común de Loot o "Tesoro").

Mecanismo: Si el objeto capturado es un libro de Mending, cancela el evento, elimina el objeto del mundo y notifica al jugador.

onLootChestOpen(InventoryOpenEvent event):

Propósito: Bloquea la obtención de Mending de cofres generados que contienen botín, como cofres de mazmorras o barriles.

Mecanismo: Se dispara cuando un jugador abre un inventario. Itera sobre el contenido del cofre/barril y, si encuentra un libro de Mending, lo elimina del inventario y notifica al jugador.

NOTA DE ARQUITECTURA: Este método usa InventoryOpenEvent, que es limitado y puede actuar en cofres colocados por jugadores. Es una restricción de gameplay amplia para la progresión de Mending.

PlayerListener.java
=
El PlayerListener es el componente de más alto nivel que gestiona el ciclo de vida del jugador, la seguridad de autenticación y la inicialización del estado RPG (vida, atributos, scoreboard).

Arquitectura de Seguridad (Login Wall)
Utiliza un Set<UUID> (unauthenticatedPlayers) para bloquear todas las interacciones de un jugador hasta que el LoginCommand o RegisterCommand llame a onLoginSuccess().

Depende del AuthManager para determinar si un jugador está registrado y para marcar su estado de logout.

Funciones Principales
onPlayerJoin(PlayerJoinEvent event):

Propósito: Punto de entrada para la seguridad y la inicialización.

Mecanismo: Verifica el estado de autenticación con el AuthManager. Si no está autenticado, añade el UUID al set de bloqueo y envía el mensaje de /login o /register. Si ya estaba logueado, llama a onLoginSuccess.

onPlayerQuit(PlayerQuitEvent event):

Propósito: Limpieza y guardado final.

Mecanismo: Elimina el scoreboard, retira el UUID de la lista local de bloqueo, y llama a authManager.logoutPlayer() para guardar los datos de forma asíncrona y marcar el estado de logout.

Bloqueos (onPlayerMove, onCommandPreprocess, onBlockBreak, onBlockPlace):

Propósito: Implementar la barrera de autenticación.

Mecanismo: Cancelan todas las interacciones si el jugador está en el set de unauthenticatedPlayers, excepto por los comandos /login y /register.

onLoginSuccess(Player player):

Propósito: Inicialización crítica del jugador tras una autenticación exitosa (llamado desde LoginCommand).

Mecanismo:

Desbloquea al jugador (unauthenticatedPlayers.remove()).

Carga el rol y permisos (authManager.loadRoleFromData).

Aplica los atributos RPG (Fuerza, Vida Máxima) del StatManager.

Sincroniza la barra de XP vanilla.

OCULTA LA BARRA DE VIDA VANILLA y aplica el scoreboard con un retraso de 1 tick (runTaskLater) para evitar fallos de sincronización con el cliente.

isUnauthenticated(Player player):

Propósito: Método de utilidad para que otros Listeners (como el de Chat) comprueben el estado de bloqueo del jugador.

StatListener.java
=
El StatListener es el controlador principal del sistema de estadísticas RPG y la capa de balance de gameplay. Centraliza la lógica de consumo de estamina, la reducción de daño basada en estadísticas, y el control de la experiencia.

Arquitectura de Balance
Depende fuertemente del StatManager para el acceso a las estadísticas (RPGStats) en memoria y para la gestión de la BossBar de Estamina y los cooldowns.

Utiliza una constante FLAT_DAMAGE_REDUCTION_PER_DEFENSE_POINT para aplicar una reducción de daño fijo (no porcentual) a todo el daño recibido.

Lógica de Estamina y Consumo de Acción
tryConsumeStamina(...):

Propósito: Función de utilidad para verificar el cooldown de cansancio, intentar consumir el costo y notificar al jugador.

CRÍTICO: Si la estamina no se puede consumir (o está en cooldown), retorna false, lo que se usa para cancelar la acción física (ataque, salto, minado).

onPlayerToggleSprint(PlayerToggleSprintEvent):

Mecanismo: Bloquea al jugador si intenta empezar a correr y está en cooldown o no tiene el mínimo de estamina (STAMINA_MINIMUM_FOR_SPRINT).

onPlayerMove(PlayerMoveEvent):

Propósito: Controla el consumo de estamina por Salto.

Mecanismo: Detecta el movimiento vertical ascendente desde un bloque sólido y utiliza tryConsumeStamina. Si falla, cancela el evento de movimiento y ajusta la velocidad vertical para evitar el salto.

onEntityDamageByEntity(EntityDamageByEntityEvent):

Propósito: Gasto de estamina por Ataque.

Mecanismo: Llama a tryConsumeStamina. Si el consumo falla (por falta de estamina o cooldown), cancela el evento de daño para bloquear el ataque.

onBlockBreak(BlockBreakEvent):

Propósito: Gasto de estamina por Trabajo (minado, talado).

Mecanismo: Llama a tryConsumeStamina. Si falla el consumo, cancela el evento de rotura de bloque.

Lógica de Combate y Defensa
onEntityDamage(EntityDamageEvent):

Propósito: Aplica la reducción de daño RPG a todo el daño entrante.

Mecanismo: Calcula la reducción fija (FLAT_DAMAGE_REDUCTION_PER_DEFENSE_POINT * statDefense) y la resta del daño final, asegurando que el resultado no sea negativo.

Lógica de Experiencia y Nivel
onPlayerExpChange(PlayerExpChangeEvent):

Propósito: Intercepta y anula la ganancia de EXP Vanilla de Minecraft.

Mecanismo: Traduce la cantidad de EXP vanilla a EXP RPG, la añade a RPGStats (que maneja la lógica de subida de nivel), y luego establece event.setAmount(0) para bloquear el sistema de nivel de Minecraft.

handleLevelUp(...):

Propósito: Lógica ejecutada por RPGStats cuando se sube de nivel.

Mecanismo: Otorga puntos de habilidad (addUnspentPoints), aplica los nuevos atributos al jugador y fuerza la actualización de scoreboards y schedulers.

Gestión de Menú
onInventoryClick(InventoryClickEvent):

Propósito: Maneja la interacción del jugador con el Menú de Atributos RPG.

Mecanismo: Comprueba que el título coincida, cancela el evento (para evitar robo de ítems), y si el jugador tiene puntos disponibles, llama a applyPointToStat(...) en la estadística correspondiente. Tras el gasto, guarda los datos y re-abre el menú.

onPlayerQuit(PlayerQuitEvent):

Propósito: Limpieza de la sesión.

Mecanismo: Elimina la BossBar de estamina, elimina los efectos de poción RPG (lentitud, prisa) y guarda el PlayerData final (incluyendo vida y estamina actuales) antes de la desconexión.

TradeListener.java
=
El TradeListener es un Listener de alta complejidad, esencial para el sistema de Tradeo Seguro. Controla cada interacción del inventario y botón dentro de la interfaz de tradeo para garantizar que los ítems y el dinero se intercambien de forma segura y solo cuando ambos jugadores estén listos.

Arquitectura de Seguridad
Dependencia: Totalmente dependiente de TradeManager y TradeSession para gestionar el estado, las ofertas y los botones.

Identificación: Utiliza un identificador de título de inventario estricto (TRADE_TITLE_IDENTIFIER) para asegurar que solo los inventarios de tradeo sean afectados.

Funciones Principales
onInventoryClick(InventoryClickEvent event):

Propósito: Manejar toda la lógica de movimiento de ítems, botones de efectivo y el estado de "Listo".

Bloqueo: Cancela cualquier clic en slots del otro jugador, separadores, y slots de control/oferta (cancelar, estado, botones de dinero).

Manejo de Ofertas:

Si el clic es en un botón de dinero (P1_INCREASE_10, etc.), calcula la nueva oferta.

Llama a session.setMoneyOffer(player, newOffer), que se encarga de verificar el saldo y resetear automáticamente el estado de "Listo" para ambos jugadores si la oferta de dinero cambia.

Manejo de Estado/Ítems:

Si el clic es en el slot de Estado/Aceptar, llama a session.toggleReady(player).

Si el clic es en el slot de ítems propios o si se produce un movimiento de ítem (shift-click desde el inventario inferior), resetea el estado de "Listo" (session.resetReadyStatus).

onInventoryDrag(InventoryDragEvent event):

Propósito: Prevenir que el jugador arrastre ítems a slots que no le corresponden.

Mecanismo: Itera sobre todos los slots afectados por el arrastre. Si algún slot pertenece al otro jugador o es un slot de control, cancela el evento.

Reset de Estado: Si el arrastre es en los slots de ítems propios, resetea el estado de "Listo".

onInventoryClose(InventoryCloseEvent event):

Propósito: Finalizar y limpiar la sesión si un jugador cierra manualmente la interfaz.

Mecanismo: Llama a session.returnItems() para devolver los ítems a ambos jugadores. Luego, llama a tradeManager.endTrade(session) para cerrar la sesión de forma segura y cerrar el inventario del otro jugador.

VillagerTradeListener.java
=
El VillagerTradeListener reemplaza el sistema de tradeo por esmeraldas de Minecraft por una moneda de efectivo digital (CashManager), rebalanceando la economía de los aldeanos. Además, es un punto de control clave para prohibir el encantamiento Mending.

Arquitectura y Seguridad
Moneda Personalizada: Utiliza Material.EMERALD con CUSTOM_MODEL_DATA para crear un ítem que representa la moneda digital (CashStack).

Balance Asíncrono: Emplea tareas asíncronas (thenAccept y runTask) para interactuar con CashManager, asegurando que el juego no se congele durante la consulta o modificación del saldo del jugador.

Bloqueo de Concurrencia: Usa un Map de locks por UUID de aldeano (getLockForVillager) para sincronizar el acceso a la lista de recetas, previniendo race conditions durante la apertura y el tradeo.

Funciones Principales
onInventoryOpen(InventoryOpenEvent):

Conversión: Itera sobre todas las recetas del aldeano y llama a convertRecipeToCash(...).

Eliminación de Mending: Descarta cualquier receta cuyo resultado sea un Libro Encantado de Reparación (Mending).

Balance: Convierte todas las esmeraldas de ingredientes en un CashStack de valor ajustado (PRICE_MULTIPLIER), eliminando la necesidad de esmeraldas físicas.

Forzado de Nivel: Fuerza el nivel del aldeano a Maestro (5) y la experiencia a Integer.MAX_VALUE.

onTradeSelect(TradeSelectEvent):

Control Total: Cancela inmediatamente el evento (event.setCancelled(true)) para tomar el control manual del proceso de tradeo.

Verificación de Mending: Bloquea y notifica al jugador si la receta seleccionada produce Mending.

Flujo de Cobro Manual (Crítico):

Verifica si el jugador tiene los ingredientes de ítem (no Cash).

Consulta el saldo del jugador (cashManager.getCash).

Si tiene fondos, modifica el saldo del jugador (cashManager.modifyBalance, de forma asíncrona).

Si el cobro tiene éxito, llama a consumeIngredients() para eliminar los ítems de ingrediente del inventario.

Llama a applyTrade() para darle el ítem resultado.

Llama a incrementTradeUsesAndExperience() para simular el uso de la receta, la experiencia del aldeano y el reset del trade (rebalance).

consumeIngredients(Player, MerchantRecipe):

CRÍTICO: Nueva función que itera sobre los ingredientes de la receta (ignorando el CashStack) y elimina las cantidades necesarias del inventario del jugador, previniendo el glitch de ítems gratis.

getAdjustedMaxUses(...):

Limita el número de usos de la receta a un máximo de 12 (MAX_USES_CAP) para un rebalance continuo.

Role.java
=
El enumerador Role es el componente fundamental para la gestión de permisos y jerarquía dentro del servidor. Define todos los grupos de usuarios, desde la administración hasta los rangos VIP y el jugador por defecto.

Arquitectura de Roles
Rol	Jerarquía	isOp()	Permisos Clave
OWNER	Administrativo	true	Acceso total (se le otorga OP)
DEVELOPMENT	Administrativo	true	Acceso total (se le otorga OP)
MODERADOR	Staff de Moderación	false	ban, unban, gamemode, teleport
HELPER	Staff de Soporte	false	teleport (Ayuda)
MEDIA	Estatus/Especial	false	Ninguno (solo prefijo)
VIP	Estatus/VIP	false	Ninguno (solo prefijo)
PLAYER	Por Defecto	false	Ninguno

AbilityManager.java
=
El AbilityManager administra la progresión de las habilidades secundarias del jugador (ej. Sastrería, Herrería) y las habilidades de inversión de puntos (ej. Agilidad). Es la capa de lógica que se encuentra entre la entrada de EXP y la actualización de los RPGStats.

Lógica Clave y Mecanismos
EXP Acumulada (Fórmula RPG):

La experiencia requerida para cada nivel se calcula mediante una fórmula de crecimiento rápido: 50 * (Nivel ^ 1.8).

El método checkSkillLevelUp es crucial. Ahora maneja la EXP Sobrante (currentExp - requiredExpForCurrentLevel) para evitar la pérdida de progreso si el jugador sube múltiples niveles a la vez.

Habilidades de Inversión de Puntos (AGILITY):

Se introduce el concepto de habilidades que usan Puntos de Habilidad en lugar de EXP pasiva (determinado por AbilityType.usesPoints()).

getAbilityPoints / setAbilityPoints se utilizan para manipular directamente el nivel de habilidades como AGILITY, que se usará para el sistema de Ofuscamiento de Cofres.

Seguridad y Límites:

Todas las ganancias de EXP y subidas de nivel están limitadas por el valor maxLevel definido en el enumerador AbilityType.

Se realiza un guardado de datos (plugin.getUserDataManager().savePlayerData) en cada actualización de EXP o puntos, garantizando la persistencia del progreso.

Métodos Principales
Método	Propósito	Seguridad
addExp(...)	Añade EXP y gatilla la subida de nivel para habilidades pasivas.	Verifica usesPoints() y getMaxLevel().
checkSkillLevelUp(...)	Contiene el bucle de subida de nivel y la lógica de retención de EXP sobrante.	Asegura que el nivel no exceda maxLevel.
getAbilityPoints(...)	Obtiene el nivel de una habilidad activa (ej. AGILITY).	Devuelve el nivel (puntos invertidos).
setAbilityPoints(...)	Establece el nivel de una habilidad activa después de que el jugador invierte puntos.	Llama a savePlayerData inmediatamente.
getRequiredExpForNextLevel(...)	Calcula la EXP TOTAL acumulada necesaria para alcanzar el siguiente nivel.	Usa la fórmula de crecimiento exponencial.

AbilityType.java
=
Este enumerador sirve como el catálogo maestro para todas las habilidades secundarias del sistema RPG. Su objetivo principal es definir la estructura de datos que utiliza el AbilityManager para gestionar la progresión de los jugadores.

Estructura y Propósito
Cada constante en el enum (TAILORING, AGILITY, etc.) encapsula los siguientes metadatos:

Nombre Visible (displayName): Cómo se muestra la habilidad al jugador.

Descripción (description): Una breve explicación de su beneficio en el juego.

Nivel Máximo (maxLevel): El tope de progresión, asegurando que el grindeo no sea infinito.

Tipo de Progresión (usesPoints): Una bandera crítica que diferencia las habilidades:

false (Pasiva): Sube de nivel ganando experiencia (ej. MINING).

true (Activa): Sube de nivel al invertir Puntos de Habilidad (ej. AGILITY).

Impacto de AGILITY: La inclusión de AGILITY con usesPoints = true diferencia claramente este tipo de habilidad, lo cual es esencial para el sistema de ofuscamiento de cofres que planeas implementar.

ApothecaryListener.java
=
Este Listener gestiona la progresión y los beneficios de la habilidad de Alquimia (APOTHECARY), la cual está enfocada en mejorar las pociones.

Mecanismo de Progresión
La principal limitación de la API de Bukkit es que el BrewEvent no proporciona el jugador que inicia la preparación de la poción. Por ello, este sistema utiliza un enfoque de doble capa:

onPotionBrew (Marcador Temporal): Al producirse la poción, solo se aplica una bonificación temporal/marcador con nivel 0 a la PotionMeta. Esto sirve para preparar la poción para el siguiente paso.

grantExpAndNotify (Ejecución Final): Esta es la función crítica que debe ser llamada externamente por un Custom Brew Handler (un listener que detecta cuándo el jugador saca el ítem de la mesa de pociones). Solo esta función puede obtener el nivel real del jugador, aplicar la EXP y modificar los efectos de la poción de manera permanente y correcta.

Bonificación de Pociones
La habilidad aplica un modificador llamado Poder de Poción (POTION_POWER_LORE_PREFIX).

Fórmula: La bonificación es de 0.5% extra de duración o efecto por nivel de habilidad. Un jugador con Nivel 100 de Alquimia aplicará un +50% de Poder de Poción.

Aplicación de Efectos: La bonificación real se aplica modificando los efectos (PotionEffect) incrustados en la poción, aumentando su duración (duration). La lógica es robusta y busca preservar el lore existente mientras inyecta la nueva estadística.

Compatibilidad: Se usa el método meta.addCustomEffect(effect, true) con el argumento overwrite para garantizar la compatibilidad con diferentes versiones de la API.

BlacksmithingListener.java
=
Este Listener es el núcleo del sistema de crafteo de armas y herramientas, implementando la habilidad de Herrería (BLACKSMITHING). Su principal función es inyectar la lógica de RPG en los ítems recién crafteados, garantizando que el nivel de la habilidad afecte directamente la calidad y utilidad del equipo.

Mecanismos Principales
1. Requisitos de Materiales
   Se mantiene una estructura estática (MATERIAL_REQUIREMENTS) que mapea cada tipo de arma/herramienta (Madera, Piedra, Diamante, etc.) con sus requisitos específicos:

Nivel Mínimo de Herrería: Dificultad base de la receta, crucial para el cálculo de calidad.

Límite de Stat (Daño/Utilidad): Establece el tope de daño o utilidad que el ítem puede ofrecer, limitado por el Stat de Fuerza del jugador.

Requisitos Mínimos (Fuerza/Velocidad): Stats mínimos que el jugador debe poseer para usar el ítem sin penalización.

2. Cálculo de Calidad y Durabilidad
   Al craftear un ítem, el Listener:

Calidad: Utiliza QualityUtility para determinar la calidad (Raro, Épico, etc.) comparando el nivel de Herrería del jugador con el requisito mínimo del material.

Durabilidad Inicial: La calidad obtenida se traduce directamente en la durabilidad inicial del ítem. Una calidad superior significa menos daño inicial aplicado (Damageable.setDamage), comenzando el ítem con una durabilidad cercana al 100%.

3. Lore Dinámico y Requisitos de Stats
   El lore del ítem es generado dinámicamente (applyBlacksmithingBonus) y es fundamental para la interacción RPG:

Nombre y Calidad: El nombre del ítem es prefijado por su calidad y color correspondiente.

Requisitos de Personaje: Muestra los requisitos de Fuerza y Velocidad. El color del texto es verde si el jugador los cumple, y rojo si no, proporcionando feedback inmediato al jugador.

Límite de Stat: Muestra el tope de daño/utilidad. Si el Stat de Fuerza del jugador excede el límite del ítem, el texto se vuelve rojo, indicando que el ítem está limitando el potencial del jugador.

4. Generación de Atributos y Experiencia
   Atributos Aleatorios: Se determina la cantidad de atributos extra que el ítem debe recibir, basándose en la calidad. El proceso de aplicación de los atributos se delega a la clase AttributeGenerator.

Ganancia de EXP: La experiencia es otorgada utilizando AbilityManager, aplicando un multiplicador si el jugador usa Shift-Click para craftear múltiples ítems a la vez, garantizando un flujo de progresión justo.

TailoringListener.java
=
Este Listener gestiona la habilidad de Sastrería (TAILORING), la cual aplica toda la lógica de RPG a las armaduras (cuero, malla, hierro, etc.) crafteadas por el jugador.

Integración Centralizada
A diferencia de otras habilidades que aplican el lore y los atributos directamente, Sastrería delegan la generación de ítems a la clase RPGItemGenerator. Esto asegura que las armaduras, que son complejas por sus múltiples slots y estadísticas, sean consistentes con el resto del sistema RPG.

Mecanismos Principales
1. Requisitos de Materiales
   Se define una lista estática (MATERIAL_REQUIREMENTS) para todas las piezas de armadura. Esta lista establece dos valores clave para cada material:

Límite Máximo de Defensa (maxDefenseLimit): El tope de la estadística Defensa que el ítem puede tener. Este valor se inyecta en el lore del ítem.

Nivel Mínimo de Sastrería (minTailoringLevel): La dificultad base para craftear el ítem, esencial para que el generador calcule la Calidad final.

2. Generación y Atributos
   La función onCraftArmadura realiza el siguiente flujo:

Generación Delegada: Llama a itemGenerator.generateRPGItem(), pasando el nivel de Sastrería del jugador y la dificultad del material. Esta llamada es responsable de:

Determinar la Calidad (Común, Raro, Épico, etc.).

Aplicar un nombre basado en la Calidad y el color correspondiente.

Generar e inyectar atributos aleatorios.

Aplicar el lore de requisitos de stats.

Durabilidad Basada en Calidad: Una vez que el RPGItemGenerator ha determinado la calidad, el Listener calcula la durabilidad inicial del ítem. Un ítem de mayor calidad comienza con mucha menos penalización de daño (cercano al 0), reflejando una manufactura superior.

3. Progresión
   Experiencia: Se otorga experiencia (EXP) variable basada en la dificultad del material (siendo Netherita la que más EXP concede). La experiencia se ajusta automáticamente si el jugador usa Shift-Click para craftear múltiples piezas.

Notificación: El jugador es notificado de la calidad del ítem crafteado y la EXP obtenida, utilizando la utilidad QualityUtility para mostrar el color correcto.

AttributeApplier.java
=
Esta clase es la responsable de la sincronización entre las estadísticas RPG personalizadas del jugador (almacenadas en RPGStats) y los atributos de Minecraft (Max Health, Attack Damage, Movement Speed). Actúa como un puente entre la lógica del juego y la API nativa de Bukkit/Spigot.

Mecanismos de Aplicación
El método central es applyPlayerAttributes(Player, RPGStats), que se invoca cuando las estadísticas de un jugador cambian (por ejemplo, subida de nivel, equipamiento, o al iniciar sesión).

1. Vida (Max Health)
   Cálculo: La vida máxima del jugador es recalculada utilizando la fórmula RPGStats.BASE_HEALTH + statHealth * RPGStats.HEALTH_PER_POINT.

Sincronización: El valor nativo de Attribute.MAX_HEALTH se establece con este nuevo valor. También ajusta la vida actual del jugador si esta excede el nuevo máximo (previniendo exploits).

2. Daño (Attack Damage)
   Base: Establece el valor base de daño de Minecraft (2.0).

Modificador: Aplica un AttributeModifier (usando una NamespacedKey única) que escala directamente con el Stat de Fuerza del jugador, sumándolo al daño base.

3. Velocidad (Movement Speed)
   Base: Establece la velocidad base de Minecraft (BASE_MC_SPEED).

Modificador: Aplica un AttributeModifier que aumenta la velocidad en una cantidad pequeña por cada punto en el Stat de Velocidad del jugador.

4. Defensa y Reducción de Daño
   La clase incluye constantes clave para el balance del juego, aunque la aplicación de la Defensa Mágica y la Reducción de Daño Plano se gestiona en las clases de Listener de daño (DamageListener).

FLAT_DAMAGE_REDUCTION_PER_DEFENSE_POINT: Constante utilizada por el sistema de combate.

getAbilityBonusMagicDefense: Calcula la Defensa Mágica adicional que el jugador obtiene por su nivel en la habilidad de Sastrería.

Robustez y Limpieza
El método removeAttributeModifiers es crítico para la estabilidad. Antes de aplicar nuevos stats, garantiza que todos los modificadores antiguos (AttributeModifier) aplicados por este plugin sean eliminados. La limpieza se realiza de la manera más robusta, utilizando las NamespacedKey definidas en el constructor y, como fallback, revisando nombres legados (legacyNames) para asegurar la compatibilidad durante las actualizaciones.

LevelingManager.java
=
Esta clase es el motor del sistema de progresión RPG. Se encarga de gestionar la adición de experiencia, el cálculo de los requisitos de EXP para los siguientes niveles y la aplicación de los beneficios al subir de nivel, tanto para el Nivel Principal del jugador como para las Habilidades Secundarias.

Mecanismos de Progresión
1. Escalado de Experiencia
   El método getRequiredExpForNextLevel utiliza un sistema de crecimiento exponencial para garantizar que la progresión sea cada vez más lenta y desafiante:

EXP
requerida
​
=BASE_REQUIRED_EXP×(REQUIRED_EXP_SCALING_FACTOR)
(Nivel−1)

Con un factor de 1.20, la EXP requerida aumenta un 20% por cada nivel.

2. Adición y Verificación de EXP (addExp)
   Nivel Principal (MAIN): La EXP se añade a stats.getTotalExperience(). Al subir de nivel, el jugador recibe 3 Puntos de Atributo sin gastar (POINTS_PER_LEVEL) para distribuir en sus stats principales (Fuerza, Vitalidad, etc.).

Habilidades Secundarias: La EXP se añade al registro específico de la habilidad (ej. BLACKSMITHING, TAILORING). La subida de nivel de una habilidad se notifica con un mensaje que resume su nuevo beneficio.

3. Sincronización con Minecraft
   Barra de Experiencia: La función updatePlayerExpBar toma la EXP del nivel principal del jugador y la traduce con precisión al sistema de barra de experiencia nativo de Minecraft, proporcionando un indicador visual de progreso.

Aplicación de Atributos: Al subir de Nivel Principal, el LevelingManager llama a statManager.getAttributeApplier() para que se actualicen inmediatamente los atributos físicos de Bukkit (Vida Máxima, Daño, Velocidad).

Beneficios de Habilidad
El método getSkillLevelUpMessage proporciona feedback específico al jugador:

Herrería: Mayor durabilidad y estadísticas de ataque en el equipo crafteado.

Sastrería: Mayor probabilidad de obtener mejores bonificaciones de defensa y velocidad en las armaduras.

Alquimia: Un aumento del 0.5% por nivel en la efectividad de las pociones.

LevelingManager.java
=
Esta clase es el motor del sistema de progresión RPG, ubicada en la carpeta stats. Su propósito es gestionar la adición de experiencia, el escalado de niveles y la aplicación de beneficios.

Principio de Coordinación (Delegación)
Dado que la arquitectura del proyecto divide la lógica en clases especializadas, LevelingManager opera bajo la coordinación del StatManager para mantener la consistencia y la limpieza:

Acceso a Stats: Obtiene el RPGStats del jugador a través de statManager.getStats().

Actualización de Atributos (Bukkit): Llama a statManager.getAttributeApplier().applyPlayerAttributes() al subir de nivel principal.

Persistencia (Guardado): Resuelve el problema de la firma de guardado delegando la tarea. Llama a statManager.savePlayerStats(player.getUniqueId()). Esto evita que LevelingManager tenga que preocuparse por la conversión de UUID a PlayerData, manteniendo la capa de persistencia aislada en el StatManager.

Mecanismos de Progresión
1. Escalado de Experiencia
   La experiencia requerida para subir de nivel utiliza un sistema de crecimiento exponencial con un factor de escalado de 1.20. Esto asegura que el esfuerzo requerido aumente progresivamente, manteniendo el juego desafiante a niveles altos.

2. Subida de Nivel y Recompensas
   Nivel Principal (MAIN): Al subir de nivel, el jugador recibe 3 Puntos de Atributo para gastar en stats principales (Fuerza, Vitalidad, etc.). El cambio desencadena una actualización inmediata de los atributos de Minecraft (MAX_HEALTH, ATTACK_DAMAGE, MOVEMENT_SPEED).

Habilidades Secundarias: El jugador es notificado del nuevo nivel y su beneficio directo:

Herrería: Mayor calidad y durabilidad en armas/herramientas.

Sastrería: Mejora las bonificaciones de armaduras.

Alquimia: Otorga un aumento del 0.5% por nivel en la efectividad de las pociones.

3. Sincronización con Minecraft
   La función updatePlayerExpBar es crucial, ya que traduce la progresión interna del sistema RPG a la barra de experiencia nativa de Minecraft, proporcionando feedback visual en tiempo real del progreso del Nivel Principal.

MenuBuilder.java
=
Esta clase es la responsable de construir y gestionar la Interfaz de Usuario (UI) para el sistema de atributos RPG. Actúa como la capa de presentación que traduce los valores numéricos internos del jugador en información legible y dinámica dentro de un inventario de Minecraft.

Arquitectura y Delegación
MenuBuilder no contiene lógica de juego ni cálculos complejos; en su lugar, delega estas responsabilidades a las clases de utilidad para asegurar una arquitectura limpia:

StatManager: Se usa para obtener el objeto RPGStats actual del jugador.

AttributeApplier: Utilizado para calcular y mostrar el valor total de atributos de Bukkit, como la Vida Máxima.

LevelingManager: Se encarga de proporcionar las fórmulas necesarias para calcular la experiencia total requerida y el progreso porcentual de las Habilidades Secundarias.

Estructura del Menú y Atributos
El menú principal de estadísticas es un inventario de 27 slots que presenta dos categorías clave: Atributos Principales (mejorables) y Habilidades Secundarias (de progresión pasiva).

Atributos Principales (Mejorables)
Cada ítem de atributo muestra el valor actual y el valor proyectado en el siguiente nivel.

Agilidad: Muestra el valor de Evasión (%) actual (Dodge Chance), calculada con 0.2% por punto de Agilidad.

Defensa Total: Muestra la Reducción Plana/Punto (Defensa Física) que el jugador posee. Se ha eliminado toda referencia a la Defensa Mágica.

Fuerza & Vida Máxima: Muestran el daño base y la vida total, respectivamente.

Estamina y Regeneración: Muestran los puntos máximos de Estamina y su recuperación por segundo (Puntos/s).

Velocidad de Recolección: Muestra los porcentajes de Velocidad de Minado y Talado.

Habilidades Secundarias
Se presentan con su nivel actual, la experiencia total y el porcentaje de progreso hasta el siguiente nivel.

Herrería: Mejora la calidad del equipo crafteado.

Sastrería: Mejora las armaduras de tela y cuero.

Alquimia: Aumenta la efectividad de las pociones.

Interacción y Lore Dinámico
El método createStatLore es fundamental. Genera el texto descriptivo (Lore) para cada ítem, adaptándose al stat específico (mostrando porcentajes, unidades como HP/s, etc.).

El mensaje "Click Izquierdo: Subir Nivel" solo es visible si el jugador tiene Puntos de Habilidad disponibles (unspentPoints > 0), guiando la acción del jugador de forma clara.

RegenerationScheduler.java
=
Esta clase fundamental gestiona la lógica de regeneración de vida (Health) y gestión de estamina (Stamina) para todos los jugadores en línea. Opera mediante una tarea programada periódica para aplicar cambios de manera eficiente.

Mecanismos Principales
El scheduler se ejecuta cada REGEN_TICK_RATE (10 ticks, o 0.5 segundos), asegurando que los cálculos por segundo se distribuyan uniformemente.

1. Gestión de Estamina
   La Estamina se gestiona con una lógica estricta que castiga el agotamiento total:

Gasto por Sprint: La estamina disminuye cuando el jugador está corriendo (player.isSprinting()) a una tasa constante (staminaCostPerTick).

Regeneración: Solo ocurre cuando el jugador no está corriendo y no está en cooldown. La tasa es dinámica, basada en el stat de Regeneración de Estamina del jugador.

Cooldown por Agotamiento: Si la estamina llega a cero, el jugador entra en un estado de cansancio (STAMINA_COOLDOWN_SECONDS).

Se aplica un debuff de lentitud (SLOWNESS).

El sprint se interrumpe y se bloquea durante el cooldown.

Se muestra un mensaje al jugador (ActionBar) notificando el agotamiento.

Visualización: Se delega la actualización visual de la estamina al StaminaBossBarManager.

2. Regeneración de Vida (Health)
   La recuperación de vida sigue un proceso más simple, escalando con el stat de Regeneración de Vida del jugador:

Tasa: La vida aumenta a la tasa definida por RPGStats.getHealthRegenPerSecond(), distribuida por tick.

Condición: La vida solo se regenera si el jugador no está corriendo (!isSprinting), premiando a los jugadores que detienen la acción para descansar.

Sincronización: La vida actual se sincroniza con el objeto RPGStats y el ScoreboardManager es notificado para actualizar cualquier pantalla.

Control de la Tarea
startRegenScheduler(): Inicializa el BukkitRunnable si aún no está activo, asegurando que solo haya una tarea de regeneración ejecutándose.

stopRegenScheduler(): Cancela la tarea programada, esencial para el apagado seguro del plugin.


StaminaBossBarManager.java
=
Esta clase de utilidad es la responsable exclusiva de la presentación visual de la Estamina del jugador utilizando el sistema nativo de BossBar de Minecraft a través de la API de Kyori Adventure.

Funcionalidad Central
El gestor opera directamente sobre un mapa de BossBars proporcionado por el coordinador (StatManager), garantizando la centralización de los datos.

1. Actualización Dinámica (updateStaminaBossBar)
   El método principal se llama periódicamente desde el RegenerationScheduler para mantener la BossBar sincronizada con la Estamina actual del jugador (RPGStats):

Cálculo del Progreso: La barra muestra el porcentaje (float) de Estamina Actual respecto a la Estamina Máxima.

Gradiente de Color: El color de la barra cambia dinámicamente según el nivel de Estamina:

Verde: Estamina alta (más del 50%).

Amarillo: Estamina media (entre 25% y 50%).

Rojo: Estamina baja (menos del 25%), alertando al jugador del riesgo de agotamiento.

Sincronización: El texto del nombre de la BossBar (que muestra el valor numérico "Actual / Máximo") se actualiza y su color se sincroniza con el color de la barra misma para una mejor coherencia visual.

2. Gestión de la Barra
   Creación: Si no existe una BossBar para el jugador, se crea una nueva, se asigna al jugador (player.showBossBar()) y se almacena en el mapa.

Remoción (removeStaminaBossBar): Se utiliza cuando el jugador se desconecta o al detener el plugin, asegurando que la barra se oculte correctamente (player.hideBossBar()) y se elimine del mapa de seguimiento.

StatListeners.java: Puente de Eventos RPG
=
Esta clase implementa el interfaz Listener de Bukkit y sirve como el puente crucial entre los eventos de juego nativos de Minecraft y la lógica interna de tu sistema RPG. Centraliza la respuesta a acciones del jugador relacionadas con la vida, estamina y movimientos.

Responsabilidades Clave
1. Control de Sprint y Estamina (onPlayerToggleSprint)
   Bloqueo de Seguridad: Si un jugador intenta iniciar un sprint y su Estamina Actual es inferior a 5.0, el evento se cancela. Esto impide que el jugador se agote inmediatamente y garantiza que siempre tenga un pequeño colchón de estamina para movimientos básicos o emergencias.

2. Muerte del Jugador (onPlayerDeath)
   Al morir un jugador, la clase se encarga de limpiar cualquier estado residual del sistema RPG para evitar bugs al reaparecer:

Se utiliza StaminaBossBarManager para ocultar y eliminar la barra de Estamina.

Se elimina cualquier debuff de Lentitud (SLOWNESS) aplicado por el cooldown de Estamina.

Se limpia el estado de cooldown de Estamina (staminaCooldowns.remove) para que la regeneración pueda comenzar inmediatamente al reaparecer.

3. Reestablecimiento al Reaparecer (onPlayerRespawn)
   Al reaparecer, los stats de Minecraft deben sincronizarse con los valores del sistema RPG:

Ejecución con Delay: La lógica se ejecuta con un delay de un tick (runTaskLater(..., 1L)) para asegurar que el proceso de respawn de Bukkit haya finalizado antes de manipular los atributos.

Re-aplicación de Atributos: Se llama a AttributeApplier.applyPlayerAttributes() para garantizar que el valor de Vida Máxima de Minecraft se ajuste correctamente al valor del sistema RPG.

Vida y Estamina Completas: El jugador es curado completamente (player.setHealth(maxHealth)) y la Estamina se restaura a su valor máximo, y la BossBar se actualiza y se muestra de nuevo.

Esta clase es esencial para la robustez y la experiencia de usuario, asegurando que el estado del jugador se mantenga limpio y coherente durante las transiciones de juego.

AttributeType.java: Definición de Atributos RPG
=
Esta enumeración (enum) es un componente fundamental del sistema RPG, ya que define un catálogo estricto de todos los atributos que pueden existir en el juego. Su propósito principal es estandarizar los stats que pueden ser aplicados a jugadores, ítems (armas/armaduras) o consumibles.

Estructura
Cada constante de la enumeración almacena dos propiedades esenciales para su uso en la presentación del juego:

displayName: El nombre legible y formateado que se muestra al usuario (ej. en el lore de un ítem).

color: El color de ChatColor asociado, utilizado para mantener la coherencia visual del atributo en menús y descripciones.

Categorías de Atributos
La lista actual de atributos se divide lógicamente en categorías para facilitar el mantenimiento y la lectura:

⚔️ Combate y Estadísticas Base
STRENGTH (Fuerza): Daño de ataque base. (Rojo)

AGILITY (Agilidad): Contribuye a la evasión y el movimiento. (Amarillo)

DEFENSE (Defensa): Reducción de daño físico plana. (Azul)

ATTACK_SPEED (Velocidad de Ataque): Frecuencia con la que el jugador puede atacar. (Cian)

ATTACK_RANGE (Alcance): Distancia efectiva del ataque. (Morado Claro)

✨ Utilidad
HEALTH_REGEN (Regeneración de Vida): Tasa de recuperación de HP por segundo. (Verde Oscuro)

CRITICAL_CHANCE (Probabilidad Crítica): Posibilidad de infligir daño extra. (Dorado)

🔨 Herrería (Crafting)
DURABILITY_BONUS (Bonus de Durabilidad): Ejemplo de un stat que podría ser añadido a ítems crafteados con la habilidad de Herrería. (Blanco)

Esta clase garantiza que cualquier nuevo atributo añadido al sistema se defina en un único lugar, manteniendo la consistencia de los nombres y colores en toda la aplicación.

MonsterListener.java: Motor de Combate y Nivelación de Mobs
=
Esta clase es un Listener central en el sistema RPG, encargada de la inicialización de atributos, la gestión de la dificultad en combate, y la recompensa de experiencia para los monstruos. Actúa como el puente entre los eventos de spawn y daño de Bukkit y la lógica personalizada de nivelación RPG.

1. Asignación de Nivel y Atributos
   El método onCreatureSpawn garantiza que todos los mobs vivientes (LivingEntities) que aparecen en el mundo sean procesados para obtener atributos RPG.

Exclusiones: Los jugadores y los mobs creados por Spawners (que por defecto se asumen como Nivel 1) son ignorados o tratados de manera especial para evitar el escalado en áreas controladas.

Nivel Dinámico: El nivel del monstruo se determina dinámicamente llamando a WorldDifficultyManager.getSpawnLevel(), lo que permite que el nivel del mob dependa de la ubicación del spawn.

Inicialización: Se crea un objeto RPGMonster, se le asigna el nivel y se llama a rpgMob.applyAttributes() para modificar sus atributos base (como vida máxima).

Metadata: El objeto RPGMonster se guarda directamente en la metadata de la entidad bajo la clave RPG_METADATA_KEY, garantizando que sus stats persistan durante toda su vida.

Visualización: Se aplica una etiqueta de nombre (NameTag) que muestra el nivel del mob: [Lv. X] NombreOriginal.

2. Lógica de Combate: Aplicación de Defensa
   El handler onEntityDamage intercepta el daño para aplicar la defensa personalizada del mob:

Reducción de Daño: Si la entidad dañada tiene metadata RPGMonster, se recupera su valor de DefenseReduction (Defensa).

Fórmula: El daño final es el resultado de restar directamente la defensa del daño original: Daño Final = MAX(0.1, Daño Original - Defensa). Se asegura un daño mínimo de 0.1 para evitar combates estancados.

Feedback: Si el atacante es un jugador, se le muestra un ActionBar detallando el daño original, la reducción aplicada por defensa, y el daño final, mejorando la inmersión.

3. Recompensa de Experiencia (EXP)
   Al morir un mob, onEntityDeath gestiona la recompensa de experiencia:

Bloqueo Vanilla: La experiencia vanilla (event.setDroppedExp(0)) se bloquea por completo.

Recompensa Custom: El valor de la EXP a otorgar (rpgMob.getExpReward()) es recuperado del objeto RPGMonster.

Sistema Centralizado: La EXP es otorgada al jugador que mató al mob (killer) utilizando plugin.getXPManager().addExp(), asegurando que la nivelación se gestione de forma unificada.

Limpieza: Se elimina la metadata RPG_METADATA_KEY del mob para una limpieza adecuada de la memoria.

ParryManager.java: Sistema de Esquivar (Dodge)
=
Esta clase implementa un sistema de habilidad activa, permitiendo a los jugadores esquivar o bloquear el daño inminente utilizando la tecla Shift (Sneak). La funcionalidad se basa en otorgar un breve período de invulnerabilidad que requiere precisión y está limitado por un cooldown.
Flujo de Activación
Evento de Agacharse (onPlayerToggleSneak): Solo se activa cuando el jugador comienza a agacharse.

Chequeo de Cooldown: Si el jugador está en cooldown, se le informa a través de la ActionBar con el tiempo restante.

Activación (activateDodge): Si el cooldown está listo, el jugador entra en el estado isInvulnerable = true y se inicia un cooldown de 3 segundos.

Finalización: Un BukkitRunnable programado para 16 ticks (0.8s) termina el estado de invulnerabilidad y notifica al jugador.

Prevención de Daño (onEntityDamage)
Este handler intercepta todos los eventos de daño dirigidos al jugador.

Si el flag isInvulnerable es true, el evento de daño se cancela (event.setCancelled(true)) y el jugador recibe una notificación de éxito en la ActionBar.

Almacenamiento y Limpieza
Se utilizan dos mapas HashMap (cooldowns y isInvulnerable) para gestionar el estado de cada jugador por su UUID. El evento onPlayerQuit asegura que la información del jugador se elimine de ambos mapas al desconectarse, previniendo fugas de memoria y bugs de estado.

QualityUtility.java: Gestión de Calidad de Ítems
=
Esta clase es un utility central que encapsula toda la lógica relacionada con la calidad de los ítems crafteados (Armas, Armaduras y Herramientas) en el sistema RPG. Define los rangos de calidad, sus beneficios inherentes y la fórmula para calcular la calidad obtenida.

1. Definición de Calidades
   Se utilizan LinkedHashMap para definir las calidades en orden estricto, desde Común hasta Mítico. Cada calidad tiene beneficios específicos:

Calidad	Color	Durabilidad Inicial	Atributos Aleatorios
Común	Gris	20%	1
Raro	Azul	40%	2
Épico	Púrpura	60%	3
Legendario	Dorado	80%	4
Mítico	Rojo	100%	5

Exportar a Hojas de cálculo
Durabilidad Inicial: Representa el porcentaje de durabilidad con el que se genera el ítem, lo cual significa que un ítem Mítico comienza con la durabilidad completa.

Atributos Aleatorios: Indica cuántos stats RPG aleatorios se añadirán al lore del ítem.

2. Lógica de Cálculo (calculateQuality)
   El método calculateQuality es el corazón del sistema, determinando la calidad final del ítem a través de una fórmula de éxito progresivo:

Probabilidad Base de Éxito (successChance): Se calcula en función del skillLevel (nivel de habilidad del jugador en Herrería o Sastrería) en relación con la difficultyLevel (dificultad del material, ej. Netherite es más difícil que el Hierro).

Un nivel de habilidad mucho mayor que la dificultad aumenta la successChance hacia el 100%.

Existe un mínimo de 5% para la successChance.

Prueba de Calidad Secuencial: El sistema itera a través de las calidades (Común, Raro, Épico...). Para cada calidad superior, la successChance se penaliza.

El jugador debe superar una prueba aleatoria para "pasar" al siguiente nivel de calidad.

La calidad final es la más alta que el jugador logró superar con éxito.

3. Utilidades de Presentación
   La clase también proporciona métodos helper para asegurar la coherencia visual en toda la aplicación:

getNamedColorForQuality y getChatColorForQuality: Devuelven los códigos de color de Kyori Adventure y Bukkit, respectivamente, para aplicar formato al nombre y al lore del ítem.

getQualityFromItem: Permite leer la calidad de un ítem existente inspeccionando la primera palabra de su nombre de visualización, lo cual es esencial para el manejo de ítems ya crafteados.

RPGItemGenerator.java: Fábrica de Ítems RPG
=
Esta clase de utilidad es responsable de tomar un ítem base y transformarlo en un ítem RPG completo, asignándole una calidad, un nivel y un conjunto de atributos aleatorios. Es el punto de control para la inyección de la lógica RPG en el crafteo y la generación de loot.

Flujo de Generación (generateRPGItem)
El proceso de generación sigue cuatro pasos esenciales, asegurando que todos los parámetros del ítem sean coherentes:

Determinación de Calidad: Llama a QualityUtility.calculateQuality() para obtener la calidad final ("Raro", "Legendario", etc.) basada en la habilidad del crafteador y la dificultad del material.

Determinación de Nivel: Llama a determineItemLevel() para asignar un nivel al ítem, que nunca supera el nivel de habilidad del crafteador.

Generación de Atributos: Llama a generateAttributes() para seleccionar una cantidad de stats aleatorios dictada por la calidad, y asignarles un valor limitado por el nivel del ítem.

Personalización: Llama a customizeItem() para aplicar la metadata visual (nombre, color, lore).

Lógica de Balance
Nivel del Ítem (determineItemLevel)
El nivel del ítem se genera con un sesgo estadístico hacia el nivel de habilidad del crafteador (crafterLevel).

El nivel mínimo es 25% del nivel del crafteador, asegurando que el ítem sea siempre relevante.

El uso de Math.sqrt(random.nextDouble()) sesga la distribución de probabilidad hacia valores más altos, resultando en que la mayoría de los ítems generados estén muy cerca del nivel máximo del jugador.

Potencia de Atributos (generateAttributes)
La potencia de los stats aleatorios está rigurosamente controlada para evitar ítems overpowered:

Límite Máximo: El valor del atributo es proporcional al nivel del ítem (ej. 0.1 * itemLevel). Un ítem de nivel 100 tendrá un potencial de stats mucho mayor que uno de nivel 10.

Selección: La cantidad de atributos seleccionados es determinada por la calidad (1 para Común, 5 para Mítico), utilizando QualityUtility.

Rango: El valor final del atributo se genera aleatoriamente en el rango [1.0, MaxValue].

Presentación (Visual)
Nombre: El nombre del ítem se formatea usando la API de Kyori Adventure, mostrando la calidad en color y el nombre base en mayúsculas (ej: [ÉPICO] ESPADA DE DIAMANTE).

Lore: Se añade el Nivel del Ítem y la Habilidad utilizada. Los atributos aleatorios se listan utilizando el color asociado a cada AttributeType.

NOTA IMPORTANTE: Actualmente, el nivel y los atributos se guardan solo en el lore (texto). Para la persistencia (supervivencia a reinicios y recargas), es crucial implementar el guardado de estos datos en los Persistent Data Containers (PDC) del ItemMeta.

RPGMonster.java: Modelo de Monstruo Escalado
=
Esta clase fundamental actúa como el modelo de datos y el motor de escalado para todos los monstruos en el juego. Su propósito es calcular y aplicar las estadísticas de combate de un mob basándose en su nivel asignado, utilizando fórmulas de escalado robustas.

Fórmulas de Escalado (Robustez)
Para evitar que los mobs de alto nivel sean triviales, la mayoría de los stats clave utilizan una combinación de escalado lineal y cuadrático.

Stat=Base+(Lineal×Nivel)+(Cuadr
a
ˊ
tico×Nivel
2
)
Escalado Cuadrático: El uso de factores cuadráticos (* \text{LvlDiff}^2) asegura que la Vida Máxima y el Daño de Ataque se disparen a niveles altos (ej. Nivel 100), manteniendo la dificultad relevante para jugadores de end-game.

Estadística	Escalado	Impacto
Vida Máxima	Cuadrático	Determina la durabilidad del mob.
Daño de Ataque	Cuadrático	Asignado al atributo ATTACK_DAMAGE de Minecraft.
Reducción de Defensa	Cuadrático	Un valor plano que se resta del daño recibido.
Resistencia al Empuje	Lineal	Escala hasta un máximo de 1.0 (100%), dificultando el control de crowd control a niveles altos.
Recompensa de EXP	Exponencial	Crece rápidamente con el nivel (FACTOR^{Nivel-1}) para que la recompensa justifique el riesgo.

Exportar a Hojas de cálculo
Aplicación de Atributos (applyAttributes)
El método applyAttributes es el punto donde la lógica RPG se inyecta en la entidad de Minecraft:

Vida Máxima: Se establece el Attribute.MAX_HEALTH y se cura a la entidad por completo (entity.setHealth(this.maxHealth)).

Daño de Ataque: Se establece el Attribute.ATTACK_DAMAGE.

Resistencia al Empuje: Se establece el Attribute.KNOCKBACK_RESISTANCE.

Las estadísticas como la Reducción de Defensa se almacenan internamente y se aplican en la clase MonsterListener cuando la entidad recibe daño, lo que permite una fórmula de reducción personalizada.

RPGStats.java: Almacén de Estadísticas de Jugador
=
Esta clase es el modelo de datos principal que almacena toda la progresión y personalización de un jugador en el sistema RPG. Está diseñado para ser persistente (guardado y cargado por el UserDataManager) y centraliza las fórmulas de cálculo de atributos y recursos.

Estructura de Progresión
La clase se organiza en tres secciones principales de progresión:

1. Progresión Principal
   level / totalExperience: Nivel principal del jugador y EXP acumulada.

unspentPoints: Puntos de habilidad disponibles para ser invertidos.

Cada subida de nivel principal otorga 1 punto (addExpTotal).

Lógica de EXP: El método addExpTotal utiliza un bucle while y la fórmula getExpForNextLevel para procesar correctamente la EXP, asegurando que se suban múltiples niveles si la EXP ganada es excesiva.

2. Habilidades Secundarias (Skills)
   skillLevels / skillExperience: Dos mapas que almacenan el nivel y la EXP individual de habilidades como Herrería (BLACKSMITHING), Sastrería (TAILORING), etc.

Método addExp(AbilityType, ...): Este método es el punto de entrada recomendado para sumar EXP a una habilidad secundaria, ya que gestiona automáticamente las notificaciones y las subidas de nivel (incluso múltiples) hasta el Nivel 100.

3. Atributos Invertibles (Stats)
   Estos campos almacenan la cantidad de puntos que el jugador ha invertido directamente usando unspentPoints.

Atributo	Foco	Factor de Conversión	Función
statHealth	Vida Máxima	+1.0 HP por punto	Aumenta la vida base de Minecraft.
statStrength	Daño	+0.5 Daño por punto	Bonus de daño de ataque.
statDefense	Defensa	+0.1 Reducción por punto	Reducción fija de daño recibido.
statStaminaMax	Estamina Máxima	+20.0 por punto	Aumenta el recurso de Estamina.
statHealthRegen	Regen. Vida	+0.05 HP/s por punto	Aumenta la regeneración pasiva.

Exportar a Hojas de cálculo
Lógica de Recursos (Vida y Estamina)
Los recursos del jugador se gestionan de forma personalizada:

Vida Máxima (getMaxHealth): Calcula la vida máxima efectiva sumando la BASE_HEALTH (20.0) más los puntos invertidos.

Vida/Estamina Actual (setCurrent...): Los setters aseguran que el valor de la vida o estamina actual nunca exceda el máximo y nunca caiga por debajo de cero.

consumeStamina: Proporciona un método seguro para gastar Estamina, verificando primero que el recurso esté disponible.

Integridad y Robustez
Constructores: El constructor por defecto inicializa las habilidades clave y establece currentHealth y currentStamina a sus valores máximos, evitando null o estados inconsistentes.

Métodos increaseStatX(): Los mutators de atributos primero llaman a spendPoint(), garantizando que solo se pueda mejorar un stat si el jugador tiene puntos disponibles.

Recarga de HP/Estamina: Al mejorar statHealth o statStaminaMax, se llama a setCurrentHealth/Stamina(getMax...), llenando el recurso por completo, lo cual es una buena práctica de experiencia de usuario.

SpawnZone.java: Definición de Zonas de Monstruos
=
Esta clase es un modelo de datos que define una región rectangular en el mundo de juego, actuando como un spawner virtual de monstruos. Centraliza las reglas sobre qué monstruos aparecen, con qué niveles y bajo qué condiciones.

Estructura de Datos
La clase almacena dos conjuntos principales de datos:

Parámetros de Área (Bounding Box):

worldUID: El ID único del mundo para garantizar la unicidad.

x1, y1, z1, x2, y2, z2: Las coordenadas de las esquinas del cubo. El constructor asegura que los valores se guarden como min y max usando Math.min y Math.max para simplificar la lógica de verificación espacial.

Parámetros de Spawning:

minLevel / maxLevel: El rango de niveles RPG que tendrán los monstruos generados en esta zona.

mobTypes: Una lista de enums EntityType que especifica qué mobs puede generar esta zona (ej. ZOMBIE, SKELETON).

maxMobs: El límite de mobs que pueden existir simultáneamente en esta zona.

spawnDelayTicks: La frecuencia con la que un gestor de spawner debe intentar generar un nuevo mob en esta zona (ej. 20 ticks = 1 segundo).

Funcionalidad Clave (contains)
El método contains(Location) es esencial. Permite que el sistema verifique rápidamente si un jugador, un monstruo, o un punto de generación potencial, se encuentra dentro de los límites de esta zona.

La verificación es robusta, comprobando primero que el worldUID coincida antes de realizar la verificación de coordenadas x, y y z.

Uso
Esta clase está diseñada para ser leída desde archivos de configuración (YAML o JSON) y gestionada por un SpawnZoneManager global, que luego la utiliza un MobSpawnListener o un scheduler de tareas para generar mobs.

StatManager.java: Coordinador de Atributos RPG
=
La clase StatManager actúa como el coordinador principal (patrón Facade) de todo el subsistema de estadísticas RPG. Su función es centralizar la inicialización, la comunicación entre submódulos y el acceso a los datos persistentes del jugador.

Cualquier otra clase de tu plugin debe interactuar con la lógica RPG solo a través del StatManager, lo que reduce el acoplamiento y facilita la escalabilidad.

Responsabilidades Clave
Inicialización de Módulos: En el constructor, StatManager inicializa y enlaza todos los managers de estadísticas:

LevelingManager

AttributeApplier (que maneja la aplicación de HP/Daño/Velocidad de forma persistente en los atributos de Minecraft).

StaminaBossBarManager (gestiona la barra de estamina).

RegenerationScheduler (la tarea programada que actualiza periódicamente Vida/Estamina/Atributos).

MenuBuilder (crea la interfaz de usuario para gastar puntos).

Gestión de Recursos Compartidos: Mantiene los mapas de estado (staminaBars, staminaCooldowns) que son accedidos por múltiples módulos.

Centralización de Datos (getStats): Proporciona un método seguro y único para obtener el objeto RPGStats de un jugador desde el UserDataManager, incluyendo una lógica de fallback robusta en caso de fallos de carga.

Control de Comandos: Implementa el comando /stats o /atributos para dar acceso directo al menú de inversión de puntos.

Persistencia: Define las NamespacedKey (healthKey, damageKey, speedKey) utilizadas por AttributeApplier para garantizar la persistencia de los modificadores de atributos a través de recargas.

Flujo de Trabajo
Al iniciar el plugin, se crea una instancia de StatManager.

El StatManager inicia el RegenerationScheduler, el cual se ejecuta periódicamente (cada tick o cada pocos ticks).

El scheduler llama a AttributeApplier.applyPlayerStats() para actualizar el HP/Daño/Velocidad del jugador basándose en los puntos invertidos en RPGStats.

El scheduler también llama a StaminaBossBarManager para actualizar visualmente la estamina del jugador y a su propia lógica para regenerar Vida/Estamina.

Cuando un jugador ejecuta /stats, el StatManager llama a MenuBuilder.openStatMenu() para construir la interfaz.

El StatManager es la columna vertebral que mantiene todo tu sistema de estadísticas sincronizado y activo.

WorldDifficultyManager.java: Motor de Dificultad Global
=
Esta clase gestiona la dificultad de los monstruos a nivel mundial, basándose en la estrategia de un escalado lento pero constante atado al tiempo real, complementado con zonas de nivel fijo definidas por la administración.

Estrategia de Balance Ajustada
La dificultad se divide en dos categorías, lo que garantiza el control del administrador sin eliminar la progresión del servidor.

Tipo de Monstruo	Mecanismo de Nivel	Comportamiento
Global (Spawn natural)	Nivel Base Global (escrito en config) + Variación Aleatoria	Su nivel aumenta 1 vez cada 24 horas reales. Son el desafío progresivo del mundo.
Fijo (Dentro de SpawnZone)	Nivel Min/Max definido en la zona.	Su nivel nunca cambia por el tiempo. Ideal para zonas de farmeo o inicio.

Exportar a Hojas de cálculo
Lógica de Escalado Temporal
Tasa: El nivel base global sube 1 nivel cada 1 día real (DAYS_PER_LEVEL_INCREASE = 1).

Implementación: Una tarea asíncrona (startDailyChecker) se ejecuta exactamente cada 24 horas para incrementar el contador serverDays y aplicar la subida de globalBaseLevel.

Notificación: Al subir el nivel global, se envía un mensaje de broadcast a todos los jugadores para avisarles del aumento de dificultad.

Cálculo de Nivel (getSpawnLevel)
Este método determina el nivel final del monstruo en el punto de aparición:

Prioridad: Primero verifica si la Location está dentro de cualquier SpawnZone. Si lo está, el nivel se extrae del rango fijo de la zona.

Dificultad Global: Si no está en una zona definida, el nivel se calcula como:

Nivel Final=Random(GlobalBaseLevel,GlobalBaseLevel+LEVEL_VARIANCE)

Donde LEVEL_VARIANCE es un factor de 5 niveles, asegurando que siempre haya una pequeña variación de desafío.

Persistencia y Administración
La clase es responsable de cargar y guardar la configuración (globalBaseLevel y serverDays) para mantener la progresión del servidor.

Los métodos addZone y removeZone permiten la administración por comandos para crear y modificar zonas de nivel fijo de manera sencilla y segura.

AttributeApplier.java: El Traductor de Atributos
=
Este componente es el puente crítico entre el sistema RPG personalizado de VendralyCore y el sistema de atributos nativos de Minecraft (Vida Máxima, Daño y Velocidad de Movimiento). Su única responsabilidad es leer los puntos de estadística de un jugador y aplicarlos como modificadores de Bukkit.

Función Principal: applyPlayerAttributes(Player)
Este método se invoca siempre que las estadísticas de un jugador cambian, ya sea por una subida de nivel, equipamiento o al iniciar sesión. Sigue un proceso de tres pasos esencial para la estabilidad:

Obtención de Datos: Obtiene el objeto RPGStats a través del StatManager, asegurando que estamos trabajando con la única fuente de verdad en memoria.

Limpieza: Ejecuta removeAttributeModifiers para eliminar todos los modificadores aplicados previamente por este plugin.

Aplicación: Vuelve a aplicar la Vida Máxima, el Daño de Ataque y la Velocidad de Movimiento, basándose en los valores actuales de RPGStats.

Mecanismo de Limpieza (1.21.8 Purpur)
El método removeAttributeModifiers utiliza la sintaxis más moderna y eficiente para eliminar modificadores sin depender de métodos obsoletos (deprecated).

En lugar de usar el UUID, itera sobre la colección de modificadores activos (damageAttr.getModifiers()) y utiliza el NamespacedKey (mod.getKey()) para identificar y eliminar solo los modificadores que pertenecen a VendralyCore. Esto garantiza que no haya duplicación de efectos al recalcular atributos.

Mecanismo de Aplicación de Stats
Vida Máxima (MAX_HEALTH): El valor calculado de RPGStats.getMaxHealth() se aplica directamente al atributo con healthAttr.setBaseValue(). Esto sobrescribe cualquier valor base anterior.

Daño (ATTACK_DAMAGE) y Velocidad (MOVEMENT_SPEED): Para estos, se crea un nuevo AttributeModifier en cada recálculo. Se utiliza el constructor no-obsoleto de 4 argumentos (NamespacedKey, valor, operación, UUID) y el valor del modificador se escala directamente con los puntos de Fuerza y Velocidad del jugador.

XPManager.java: Gestión de Progresión y Nivel
=
La clase XPManager es el motor central de la progresión de los jugadores. Se encarga de calcular la curva de experiencia, procesar la adición de XP, gestionar las subidas de nivel y sincronizar el progreso con la barra de experiencia nativa de Minecraft.

Curva de Nivelación
La dificultad está definida por dos constantes clave:

BASE_XP (200): La experiencia base requerida para alcanzar el Nivel 2.

XP_MULTIPLIER (1.15): El factor de crecimiento exponencial que asegura que cada nivel sea un 15% más difícil que el anterior, creando una curva de progresión sostenible a largo plazo.

El método getXPForNextLevel(int level) utiliza estos valores para calcular dinámicamente el requisito de experiencia total para subir al siguiente nivel.

Adición de Experiencia y Nivelación (addXP)
Este es el método principal que se llama cuando un jugador realiza una acción que otorga experiencia (matar un monstruo, completar una misión, etc.).

Validación de Datos: Accede al RPGStats del jugador a través del StatManager, manteniendo la Regla de la Fuente de Verdad (tal como se define en el README.md).

Procesamiento de Bucle: Utiliza un bucle while para garantizar que toda la cantidad de XP añadida sea procesada, permitiendo al jugador subir varios niveles de golpe si la cantidad de XP es muy grande.

Recompensas: Por cada nivel ganado, el jugador recibe STAT_POINTS_PER_LEVEL (1) punto de atributo no gastado, listo para ser asignado.

Sincronización Crítica: Tras una subida de nivel (leveledUp = true), se llama a statManager.getAttributeApplier().recalculateStats(player). Este paso es vital, ya que fuerza al sistema a aplicar instantáneamente cualquier aumento de Vida, Daño o Velocidad resultante del nuevo nivel.

Interfaz de Usuario (updateVanillaXPBar)
La clase se encarga de que el progreso de nivelación del sistema custom se refleje visualmente en el juego.

El método updateVanillaXPBar(Player) toma el nivel custom y el progreso de XP del RPGStats y lo traduce a los métodos de la API de Bukkit:

player.setLevel(level): Establece el número flotante de nivel visible en el centro de la pantalla.

player.setExp(progress): Establece el progreso de la barra de experiencia verde, calculando la fracción de currentXP respecto al requiredXP. Esto ofrece al jugador una retroalimentación visual inmediata sobre cuánto le falta para el siguiente hito.

ZoneSpawner.java: Sistema de Spawn de Zona
=
El ZoneSpawner es el sistema encargado de gestionar la aparición periódica y controlada de entidades hostiles dentro de áreas geográficas predefinidas llamadas SpawnZone. Su objetivo es mantener una población constante y equilibrada de mobs sin sobrecargar el servidor ni permitir un farmeo excesivo.

Mecanismo de Tarea Periódica
La lógica principal se ejecuta mediante una tarea asíncrona de Bukkit (BukkitRunnable) que se inicia con startSpawnerTask() y se detiene con stopSpawnerTask().

La tarea se repite cada 10 segundos (200 ticks), asegurando un ciclo de spawn constante y predecible. Esto evita picos de rendimiento y mantiene la dificultad fluida.

Control de Población y Estabilidad
La estabilidad del servidor es prioritaria. Para ello, el spawner implementa un control estricto de la población de mobs:

Conteo Activo (recalculateMobPopulation): Antes de intentar cualquier spawn, el sistema recorre todos los mundos y todas las entidades vivas, contando cuántos mobs existen actualmente dentro de cada zona activa.

Mapa Sincronizado: El conteo se almacena en el mapa currentMobCount, que está sincronizado para garantizar la seguridad en un entorno multihilo.

Límite de Zona (attemptSpawnInZone): Solo si el conteo actual es estrictamente menor al límite máximo (zone.getMaxMobs()) definido para esa SpawnZone, se permite la aparición de un nuevo mob.

Este proceso de recuento periódico asegura que los mobs asesinados por jugadores o eliminados por la recolección de basura del servidor sean reemplazados de manera eficiente hasta alcanzar el máximo de la zona.

Lógica de Spawn Seguro
El método findSafeSpawnLocation(SpawnZone) es crucial para la jugabilidad, ya que resuelve el problema común del spawn en ubicaciones imposibles o peligrosas:

Busca aleatoriamente un punto dentro de los límites de la zona.

Verifica que el bloque de spawn sea no sólido (generalmente aire).

Verifica que el bloque directamente debajo sea sólido (el suelo).

Verifica que el bloque directamente encima también sea no sólido (espacio para que el mob respire).

Si después de múltiples intentos, no se encuentra un lugar seguro, el spawn es abortado, protegiendo al servidor de intentar spawns fallidos. El tipo de mob que aparece se selecciona de la lista definida en la SpawnZone de forma aleatoria.

NameTagManager.java: Gestión de Tags y Roles
=
El NameTagManager es el componente de la interfaz de usuario responsable de sincronizar el rol (Role) de un jugador con su apariencia visual dentro del juego. Su única función es aplicar el prefijo y el color de un rol tanto al nombre que aparece encima de la cabeza (Name Tag) como al nombre en la lista de jugadores (Tablist).

Mecanismo Central: Scoreboard y Equipos
La aplicación de prefijos se logra utilizando la API nativa de Scoreboard de Minecraft, que es el método estándar y más eficiente para este propósito:

Fuente del Rol: Al iniciar sesión o al actualizar un rol, el manager obtiene el Role del jugador a través del AuthManager (la fuente de verdad para los datos del jugador).

Creación de Equipo: Se utiliza el Scoreboard principal del servidor para registrar un Team nuevo si aún no existe un equipo para ese rol.

Configuración: El prefijo formateado del rol (ej. [OWNER] ) se establece en el equipo (team.setPrefix(prefix)).

Asignación: El jugador es añadido a este equipo (team.addEntry(player.getName())), lo que aplica automáticamente el prefijo en su Name Tag para todos los demás jugadores.

Prioridad y Orden de la Tablist
Para garantizar que los roles con mayor jerarquía (Owner, Dev, Mod) aparezcan correctamente ordenados al principio de la Tablist, se utiliza una convención de nomenclatura basada en la prioridad:

Nombre de Equipo: El método getTeamName(Role) genera un nombre de equipo siguiendo el formato XX-ROLENAME (ej., 10-OWNER o 01-PLAYER).

Clasificación: El prefijo numérico (XX) fuerza al Scoreboard de Bukkit a ordenar a los jugadores por el valor de prioridad, asegurando que los rangos más importantes siempre sean visibles primero en la Tablist.

Solución para Chat y Tablist
La clase maneja inteligentemente la distinción entre el nombre en la Tablist y el nombre que aparece en el chat para evitar la doble aparición de prefijos:

Tablist Completa: El método player.setPlayerListName(prefix + player.getName()) aplica intencionalmente el prefijo directamente al nombre de la lista, ya que el prefijo del Team no se aplica a la Tablist de forma nativa.

Chat Limpio: El método player.setDisplayName(player.getName()) es crucial. Si no se hiciera esto, el prefijo del Team se filtraría al chat, duplicando el prefijo que ya está manejando el plugin de chat. Al resetear el DisplayName, se asegura que el chat reciba solo el nombre limpio del jugador.

En resumen, el NameTagManager garantiza que la identidad visual del jugador sea precisa y consistente en todos los elementos de la interfaz de Minecraft, cumpliendo con los estándares de diseño y estabilidad en la versión 1.21.8.

ScoreboardManager.java: Dashboard Dinámico
=
El ScoreboardManager es el sistema de interfaz de usuario (UI) que centraliza la información crucial del jugador y del servidor en la pizarra lateral (sidebar). Su diseño robusto garantiza un rendimiento estable al manejar la compleja sincronización de datos asíncronos (como el efectivo) con la actualización síncrona de la pizarra.

Núcleo del Sistema: Tarea de Actualización
La actualización de la pizarra se realiza mediante una tarea recurrente de Bukkit iniciada por startUpdateTask(). Esta tarea se ejecuta síncronamente cada 40 ticks (2 segundos) en el hilo principal del servidor, lo que es óptimo para la estabilidad:

Actualización Asíncrona de Efectivo: Llama a updateAllCashBalancesAsync() para refrescar la caché de efectivo de los jugadores en un entorno asíncrono.

Actualización Síncrona de UI: Llama a updateAllBoards() para redibujar el contenido de la pizarra y nameTagManager.updateAllTags() para refrescar los prefijos de los nombres.

Gestión de Datos Asíncronos (Efectivo)
La lectura de datos de la base de datos es lenta y debe ser asíncrona. Para que el efectivo (Cash) se muestre en el Scoreboard sin congelar el servidor, se utiliza un patrón de caché y cooldown:

updateAllCashBalancesAsync: Este método solicita el saldo de efectivo de cada jugador de forma asíncrona (cashManager.getCash(uuid).thenAccept(...)).

UPDATE_COOLDOWN (1 segundo): Un cooldown simple evita inundar el sistema de economía con peticiones en cada ciclo de actualización del Scoreboard, optimizando el uso de recursos.

cachedCash: El saldo de efectivo se almacena temporalmente en este mapa hasta la próxima lectura asíncrona, permitiendo que el Scoreboard dibuje un valor reciente sin esperar la base de datos.

Construcción Robusta del Scoreboard
Para evitar problemas de parpadeo y asegurar que el Scoreboard se vea limpio, se utiliza una técnica avanzada: usar Teams para ocultar la puntuación.

setScoreboardLine(Objective, Scoreboard, String, int): Este método helper es el encargado de dibujar cada línea.

Puntuación: La puntuación (score) se usa únicamente para forzar el orden de las líneas.

Entrada Única: Se genera una entrada de Scoreboard invisible y única por cada línea (getUniqueEntryByScore), usando códigos de color para evitar que los números de puntuación se muestren.

Prefijo del Team: El contenido visible de la línea (el texto, ej. "♥ Vida: 100/100") se establece como el Prefijo del Team asociado a esa entrada, permitiendo una máxima flexibilidad de formato sin la limitación de los 40 caracteres por entrada de Scoreboard.

Flujo de Datos y Coherencia
El ScoreboardManager garantiza la coherencia al depender de los Managers de datos existentes, siguiendo la Regla de la Fuente de Verdad de VendralyCore:

Datos RPG (Vida, Nivel): Se obtienen de StatManager y XPManager.

Datos de Rol: Se obtienen de AuthManager.

Los métodos de notificación (notifyHealthChange, notifyLevelChange, etc.) actúan simplemente como un alias para llamar a updatePlayerBoard(), manteniendo la lógica centralizada y fácil de mantener.

La clase también maneja la creación de Scoreboards nuevos para cada jugador (getOrCreatePlayerBoard) y la restauración segura del Scoreboard principal al desconectarse (removePlayerBoard).

AuthUtil.java: Utilidades Criptográficas
=
La clase AuthUtil es una utilidad estática que encapsula las operaciones fundamentales de seguridad de la autenticación. Su propósito es garantizar que todas las contraseñas de los usuarios sean procesadas criptográficamente antes de ser almacenadas, cumpliendo con las buenas prácticas de la industria.

Hash de Contraseñas (SHA-256)
El método hashPassword(String password) es la función principal de esta clase.

Algoritmo: Utiliza el algoritmo de hash criptográfico SHA-256 (Secure Hash Algorithm 256-bit). Este algoritmo es rápido, ampliamente aceptado y robusto, ideal para el hashing de contraseñas.

Manejo de Bytes: Convierte la contraseña de texto plano en un array de bytes, lo hashea, y luego traduce el resultado en una cadena hexadecimal legible y segura, que es lo que se guarda en la base de datos (PlayerData).

Robustez: Incluye un bloque try-catch para manejar la improbabilidad de que el algoritmo SHA-256 no esté disponible en el entorno Java, asegurando que la función no falle silenciosamente.

Verificación de Autenticación
El método checkPassword(String password, String hashedPassword) es la función que se ejecuta cada vez que un usuario intenta iniciar sesión o cambiar su contraseña.

Proceso: No compara la contraseña de texto plano con el hash almacenado. En su lugar, toma la contraseña enviada por el usuario, la hashea instantáneamente usando hashPassword(), y luego compara el nuevo hash generado con el hash que ya está almacenado en la base de datos.

Seguridad: Si el hash generado coincide con el hash almacenado, se considera que la contraseña es correcta, sin que el servidor jamás vea o almacene la contraseña en texto legible.

Nota: Aunque el uso de SHA-256 es un buen estándar, la implementación es estática y simple. No incluye salting (añadir datos aleatorios únicos antes del hash), lo que es un paso de seguridad adicional. Sin embargo, para un sistema de autenticación básica de un plugin de Minecraft, esta implementación es un comienzo seguro y funcional.

TradeGuiManager.java: Constructor de la Interfaz de Comercio Seguro
=`TradeGuiManager` es la utilidad responsable de construir el inventario de 54 slots utilizado en el comercio seguro. Se encarga únicamente del diseño visual y de los botones de confirmación.

Distribución del inventario
El inventario se divide en tres zonas: la franja izquierda (slots 0-20) para el solicitante, la franja derecha (27-44) para el objetivo y un separador central de paneles grises (21-26) que evita interacciones cruzadas.

Controles inferiores
Los slots 45 y 53 contienen bloques de esmeralda llamados "Confirmar".
El resto de la fila inferior (46-52) se rellena con paneles grises para bloquear interacciones y mantener la simetría visual.

Relación con TradeSession
La interfaz es compartida por ambos jugadores; `TradeSession` es quien controla qué slots son válidos y cuándo reiniciar el estado de confirmación si cambia alguna oferta.

TradeManager.java: Coordinador del Comercio Seguro
=`TradeManager` coordina el ciclo de vida de los intercambios: solicitudes, creación de la GUI y cierre de sesiones.

Flujo básico
1. `/trade <jugador>` almacena una solicitud en `pendingRequests` y notifica al objetivo.
2. `/trade accept <jugador>` verifica la solicitud; si coincide, crea una `TradeSession` con la GUI compartida por `TradeGuiManager`.
3. `TradeListener` vigila la interfaz; cuando ambos jugadores confirman, `TradeManager` mueve los ítems y transfiere el dinero ofrecido utilizando `CashManager`.

Seguridad operativa
* Cada jugador sólo puede tener una solicitud pendiente; una nueva sobrescribe la anterior.
* Al cerrar la interfaz se devuelven los ítems automáticamente y se limpia la sesión.
* El manager expone `tick()` y `shutdown()` para permitir futuras expansiones (por ejemplo expiraciones automáticas).

TradeSession.java: Lógica de la Transacción Segura
=`TradeSession` encapsula a los dos jugadores involucrados, su inventario compartido y el estado de confirmación.

Elementos clave
* `getRequesterSlots()` y `getTargetSlots()` definen las posiciones válidas para cada jugador.
* `setMoney(Player, double)` registra la oferta monetaria de cada lado y reinicia las confirmaciones.
* `toggleReady(Player)` alterna la marca de listo de quien presiona el botón.

Cuando ambos jugadores están listos, `TradeManager` valida los fondos disponibles y realiza el intercambio de ítems y dinero. Si la sesión se cancela o se cierra la interfaz, `endSession` devuelve cada objeto a su propietario original y limpia el estado interno.


=
La clase Main.java es el punto de entrada (JavaPlugin) del proyecto VendralyCore. Su única responsabilidad es actuar como el orquestador central: establece la configuración inicial, inicializa todas las clases manager en el orden correcto de dependencia y coordina el registro de todos los comandos, listeners y tareas programadas.

Esta clase es el hub que asegura la integridad de todos los sistemas al proporcionar acceso público a cada manager mediante sus métodos getter.

Ciclo de Inicialización (onEnable)
El método onEnable sigue un estricto orden de inicialización por capas para garantizar que ningún manager intente acceder a una dependencia que aún no ha sido creada:

Persistencia y Configuración: Inicializa primero el UserDataManager (el sistema I/O basado en YAML), creando la base para la carga y el guardado de datos.

Núcleo Base: Inicializa los gestores fundamentales: AuthManager (seguridad), EconomyManager, CashManager y TradeManager.

Núcleo RPG: Inicializa todos los subsistemas del motor RPG en orden:

StatManager (stats base y modificadores).

XPManager (curva de experiencia y puntos de atributo).

WorldDifficultyManager (niveles base y zonas de spawn).

ZoneSpawner (motor de spawn por zona).

AbilityManager (sistema de habilidades secundarias).

UI y Servicios: Inicializa PlayerListener y ScoreboardManager.

Registro y Tareas: Registra todos los comandos y listeners de todos los módulos. Finalmente, inicia las tres tareas principales de alto rendimiento:

StatManager.startRegenScheduler (Regeneración de Estamina/Vida).

ZoneSpawner.startSpawnerTask (Spawn periódico de mobs).

ScoreboardManager.startUpdateTask (Actualización de la pizarra lateral).

Cierre de Seguridad (onDisable)
El método onDisable es fundamental para la integridad de los datos del servidor. El proceso de apagado es diseñado para un cierre limpio y seguro:

Detención de Tareas: Detiene sistemáticamente todas las tareas recurrentes (Scoreboard, StatManager y ZoneSpawner) para evitar que sigan intentando ejecutarse mientras el servidor se apaga.

Persistencia:

Guarda la configuración global del mundo (difficultyManager).

Ejecuta userDataManager.saveAll(), el paso más crítico, que fuerza a todos los objetos PlayerData y RPGStats que están en memoria a escribirse en sus respectivos archivos YAML.

Cleanup: Finaliza las sesiones de BossBar de los jugadores conectados, asegurando que no queden rastros de UI custom al apagar.

Este flujo garantiza que el plugin se inicie de forma ordenada, maneje sus recursos eficientemente en tiempo de ejecución y garantice la persistencia total de los datos al cerrarse.

PlayerJoinListener.java: Sincronización de Salud NMS
=
Esta clase Listener es un componente crítico de la capa de interfaz de usuario de salud RPG. Su única responsabilidad es asegurar que la salud nativa de Minecraft se sincronice con el sistema de salud custom de VendralyCore y que la barra de salud vanilla no sea visible, evitando que se muestren dos barras de salud a la vez.

Flujo en la Conexión (onPlayerJoin)
El evento de conexión es el momento más importante para esta clase:

Obtención de Datos: Obtiene la Vida Máxima RPG (rpgMaxHealth) del jugador a través del StatManager (la fuente de verdad).

Sincronización Bukkit: Sincroniza el atributo Attribute.MAX_HEALTH de Bukkit con el valor de salud RPG obtenido. Esto es esencial para que la vida nativa del jugador (el valor subyacente que reporta el juego) sea el correcto.

Ocultar Vanilla: Utiliza el método estático NMSHealthUtil.hideVanillaHealth(player, rpgMaxHealth) para manipular la representación visual del HUD del jugador. Esto es lo que oculta los corazones nativos, dejando espacio para que tu BossBar custom de salud se dibuje sin conflictos visuales.

Flujo en el Respawn (onPlayerRespawn)
El evento de respawn se utiliza como una medida de redundancia:

Aunque Bukkit ya restablece el atributo de MAX_HEALTH al morir, el respawn puede, en algunas versiones, reiniciar o mostrar brevemente la barra vanilla.

El listener vuelve a invocar a NMSHealthUtil.hideVanillaHealth inmediatamente después de que el jugador reaparece, asegurando que la barra vanilla se mantenga oculta y que el jugador vea inmediatamente su salud custom.

En resumen, esta clase actúa como el puente de compatibilidad entre la API de Bukkit/NMS y el motor de salud RPG de tu servidor.

NMSHealthUtil.java: Ocultamiento de Salud Vanilla
=
La clase NMSHealthUtil es una utilidad estática de bajo nivel cuyo único propósito es manipular la barra de salud (corazones) nativa de Minecraft. Esto es esencial para el motor RPG de VendralyCore, ya que permite ocultar los corazones vanilla y utilizar completamente el HUD custom (generalmente una BossBar o un Canvas de salud) sin duplicidades visuales.

Mecanismo Central: El "Truco NMS"
El ocultamiento se logra mediante una técnica conocida que explota cómo el cliente de Minecraft procesa los valores del atributo GENERIC_MAX_HEALTH:

Valor de Quiebre (HIDE_VALUE): Se utiliza un valor no estándar, como 1024.0, para establecer el MAX_HEALTH de forma temporal. Este valor no tiene sentido en el contexto vanilla (el máximo normal es 1024.0, pero el juego asume 20 o 40 por defecto) y fuerza al cliente a dejar de dibujar los corazones en el HUD.

Velocidad: El truco requiere una ejecución extremadamente rápida: el valor de quiebre debe ser establecido y restaurado inmediatamente para evitar cualquier cambio real o visible en el estado del juego.

Pasos Críticos para el Ocultamiento Seguro
El método hideVanillaHealth(Player, double) ejecuta esta secuencia crítica, asegurando que la vida real del jugador no se vea afectada:

Configuración del Atributo: El MAX_HEALTH se establece temporalmente en el valor de quiebre (HIDE_VALUE = 1024.0).

Forzar Paquete: Para que el cliente procese el cambio de MAX_HEALTH, se debe forzar una actualización del valor de vida actual (player.setHealth()). Si el jugador tiene vida completa, su vida se baja mínimamente (- 0.0001) y se restaura al valor original.

Restauración Inmediata: Inmediatamente después de forzar el paquete, el valor MAX_HEALTH es restaurado a su valor real de RPG (por ejemplo, 1000.0) y la vida actual vuelve a su valor original (actualHealth).

Este proceso sucede en el mismo tick del servidor, haciendo que sea invisible e imperceptible para el jugador, pero garantizando que la barra de corazones nativa desaparezca de su HUD.

Manejo de Casos Extremos
La utilidad también verifica si el rpgMaxHealth es bajo (menor o igual a 20.0). En este caso, el truco se omite, y el atributo de salud se establece a 20.0. Esto permite que la barra de salud vanilla se muestre correctamente para jugadores que el sistema RPG considera en modo Vanilla o si tu sistema de salud custom está deshabilitado temporalmente.

